<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functional Composition Analysis - Debtmap Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive guide to Debtmap code complexity and technical debt analyzer">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Debtmap Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/iepathos/debtmap" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="functional-composition-analysis"><a class="header" href="#functional-composition-analysis">Functional Composition Analysis</a></h1>
<p>Debtmap provides deep AST-based analysis to detect and evaluate functional programming patterns in Rust code. This feature helps you understand how effectively your codebase uses functional composition patterns like iterator pipelines, identify opportunities for refactoring imperative code to functional style, and rewards pure, side-effect-free functions in complexity scoring.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Functional analysis examines your code at the AST level to detect:</p>
<ul>
<li><strong>Iterator pipelines</strong> - Chains like <code>.iter().map().filter().collect()</code></li>
<li><strong>Purity analysis</strong> - Functions with no mutable state or side effects</li>
<li><strong>Composition quality metrics</strong> - Overall functional programming quality scores</li>
<li><strong>Side effect classification</strong> - Categorization of Pure, Benign, and Impure side effects</li>
</ul>
<p>This analysis integrates with debtmap’s scoring system, providing score bonuses for high-quality functional code and reducing god object warnings for codebases with many small pure helper functions.</p>
<p><strong>Specification</strong>: This feature implements <a href="https://github.com/yourusername/debtmap/specs/111">Specification 111: AST-Based Functional Pattern Detection</a> with accuracy targets of precision ≥90%, recall ≥85%, F1 ≥0.87, and performance overhead &lt;10%.</p>
<h2 id="configuration-profiles"><a class="header" href="#configuration-profiles">Configuration Profiles</a></h2>
<p>Debtmap provides three pre-configured analysis profiles to match different codebases:</p>
<div class="table-wrapper"><table><thead><tr><th>Profile</th><th>Use Case</th><th>Min Pipeline Depth</th><th>Max Closure Complexity</th><th>Purity Threshold</th><th>Quality Threshold</th></tr></thead><tbody>
<tr><td><strong>Strict</strong></td><td>Functional-first codebases</td><td>3</td><td>3</td><td>0.9</td><td>0.7</td></tr>
<tr><td><strong>Balanced</strong> (default)</td><td>Typical Rust projects</td><td>2</td><td>5</td><td>0.8</td><td>0.6</td></tr>
<tr><td><strong>Lenient</strong></td><td>Imperative-heavy legacy code</td><td>2</td><td>10</td><td>0.5</td><td>0.4</td></tr>
</tbody></table>
</div>
<h3 id="choosing-a-profile"><a class="header" href="#choosing-a-profile">Choosing a Profile</a></h3>
<p><strong>Use Strict</strong> when:</p>
<ul>
<li>Your codebase emphasizes functional programming patterns</li>
<li>You want to enforce high purity standards</li>
<li>You’re building a new project with functional-first principles</li>
<li>You want to detect even simple pipelines (3+ stages)</li>
</ul>
<p><strong>Use Balanced</strong> (default) when:</p>
<ul>
<li>You have a typical Rust codebase mixing functional and imperative styles</li>
<li>You want reasonable detection without being overly strict</li>
<li>You’re working on a mature project with mixed patterns</li>
<li>You want to reward functional patterns without penalizing pragmatic imperative code</li>
</ul>
<p><strong>Use Lenient</strong> when:</p>
<ul>
<li>You’re analyzing legacy code with heavy imperative patterns</li>
<li>You want to identify only the most obviously functional code</li>
<li>You’re migrating from an imperative codebase and want gradual improvement</li>
<li>You have complex closures that are still fundamentally functional</li>
</ul>
<h3 id="cli-usage"><a class="header" href="#cli-usage">CLI Usage</a></h3>
<p>Enable functional analysis with the <code>--ast-functional-analysis</code> flag and select a profile with <code>--functional-analysis-profile</code>:</p>
<pre><code class="language-bash"># Enable with balanced profile (default)
debtmap analyze . --ast-functional-analysis --functional-analysis-profile balanced

# Use strict profile for functional-first codebases
debtmap analyze . --ast-functional-analysis --functional-analysis-profile strict

# Use lenient profile for legacy code
debtmap analyze . --ast-functional-analysis --functional-analysis-profile lenient
</code></pre>
<p><strong>Note:</strong> The <code>--ast-functional-analysis</code> flag enables the feature, while <code>--functional-analysis-profile</code> selects the configuration profile (strict/balanced/lenient).</p>
<h2 id="pure-function-detection"><a class="header" href="#pure-function-detection">Pure Function Detection</a></h2>
<p>A function is considered pure when it:</p>
<ol>
<li>Returns same output for same input (deterministic)</li>
<li>Has no observable side effects</li>
<li>Doesn’t mutate external state</li>
<li>Doesn’t perform I/O</li>
</ol>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pure function
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// Pure function with internal iteration
fn factorial(n: u32) -&gt; u32 {
    (1..=n).product()  // Pure despite internal iteration
}

// Not pure: I/O side effect
fn log_and_add(a: i32, b: i32) -&gt; i32 {
    println!("Adding {} and {}", a, b);  // Side effect!
    a + b
}

// Not pure: mutates external state
fn increment_counter(counter: &amp;mut i32) -&gt; i32 {
    *counter += 1;  // Side effect!
    *counter
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pipeline-detection"><a class="header" href="#pipeline-detection">Pipeline Detection</a></h2>
<p>Debtmap detects functional pipelines through deep AST analysis, identifying iterator chains and their transformations.</p>
<h3 id="pipeline-stages"><a class="header" href="#pipeline-stages">Pipeline Stages</a></h3>
<p>The analyzer recognizes these pipeline stage types:</p>
<h4 id="1-iterator-initialization"><a class="header" href="#1-iterator-initialization">1. Iterator Initialization</a></h4>
<p>Methods that start an iterator chain:</p>
<ul>
<li><code>.iter()</code> - Immutable iteration</li>
<li><code>.into_iter()</code> - Consuming iteration</li>
<li><code>.iter_mut()</code> - Mutable iteration</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Detected iterator initialization
let results = collection.iter()
    .map(|x| x * 2)
    .collect();
<span class="boring">}</span></code></pre></pre>
<h4 id="2-map-transformations"><a class="header" href="#2-map-transformations">2. Map Transformations</a></h4>
<p>Applies a transformation function to each element:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Detected Map stage
items.iter()
    .map(|x| x * 2)          // Simple closure (low complexity)
    .map(|x| {                // Complex closure (higher complexity)
        let doubled = x * 2;
        doubled + 1
    })
    .collect()
<span class="boring">}</span></code></pre></pre>
<p>The analyzer tracks <strong>closure complexity</strong> for each map operation. Complex closures may indicate code smells and affect quality scoring based on your <code>max_closure_complexity</code> threshold.</p>
<h4 id="3-filter-predicates"><a class="header" href="#3-filter-predicates">3. Filter Predicates</a></h4>
<p>Selects elements based on a predicate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Detected Filter stage
items.iter()
    .filter(|x| *x &gt; 0)      // Simple predicate
    .filter(|x| {             // Complex predicate
        x.is_positive() &amp;&amp; x &lt; 100
    })
    .collect()
<span class="boring">}</span></code></pre></pre>
<h4 id="4-foldreduce-aggregation"><a class="header" href="#4-foldreduce-aggregation">4. Fold/Reduce Aggregation</a></h4>
<p>Combines elements into a single value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Detected Fold stage
items.iter()
    .fold(0, |acc, x| acc + x)

// Or using reduce
items.iter()
    .reduce(|a, b| a + b)
<span class="boring">}</span></code></pre></pre>
<h4 id="5-flatmap-transformations"><a class="header" href="#5-flatmap-transformations">5. FlatMap Transformations</a></h4>
<p>Maps and flattens nested structures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Detected FlatMap stage
items.iter()
    .flat_map(|x| vec![x, x * 2])
    .collect()
<span class="boring">}</span></code></pre></pre>
<h4 id="6-inspect-side-effect-aware"><a class="header" href="#6-inspect-side-effect-aware">6. Inspect (Side-Effect Aware)</a></h4>
<p>Performs side effects while passing through values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Detected Inspect stage (affects purity scoring)
items.iter()
    .inspect(|x| println!("Processing: {}", x))
    .map(|x| x * 2)
    .collect()
<span class="boring">}</span></code></pre></pre>
<h4 id="7-resultoption-chaining"><a class="header" href="#7-resultoption-chaining">7. Result/Option Chaining</a></h4>
<p>Specialized stages for error handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Detected AndThen stage
results.iter()
    .and_then(|x| try_process(x))
    .collect()

// Detected MapErr stage
results.iter()
    .map_err(|e| format!("Error: {}", e))
    .collect()
<span class="boring">}</span></code></pre></pre>
<h3 id="terminal-operations"><a class="header" href="#terminal-operations">Terminal Operations</a></h3>
<p>Pipelines typically end with a terminal operation that consumes the iterator:</p>
<ul>
<li><strong><code>collect()</code></strong> - Gather elements into a collection</li>
<li><strong><code>sum()</code></strong> - Sum numeric values</li>
<li><strong><code>count()</code></strong> - Count elements</li>
<li><strong><code>any()</code></strong> - Check if any element matches</li>
<li><strong><code>all()</code></strong> - Check if all elements match</li>
<li><strong><code>find()</code></strong> - Find first matching element</li>
<li><strong><code>reduce()</code></strong> - Reduce to single value</li>
<li><strong><code>for_each()</code></strong> - Execute side effects for each element</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Complete pipeline with terminal operation
let total: i32 = items.iter()
    .filter(|x| **x &gt; 0)
    .map(|x| x * 2)
    .sum();  // Terminal operation: sum
<span class="boring">}</span></code></pre></pre>
<h3 id="nested-pipelines"><a class="header" href="#nested-pipelines">Nested Pipelines</a></h3>
<p>Debtmap detects pipelines nested within closures, indicating highly functional code patterns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Nested pipeline detected
let results = outer_items.iter()
    .map(|item| {
        // Inner pipeline (nesting_level = 1)
        item.values.iter()
            .filter(|v| **v &gt; 0)
            .collect()
    })
    .collect();
<span class="boring">}</span></code></pre></pre>
<p><strong>Nesting level</strong> tracking helps identify sophisticated functional composition patterns.</p>
<h3 id="parallel-pipelines"><a class="header" href="#parallel-pipelines">Parallel Pipelines</a></h3>
<p>Parallel iteration using Rayon is automatically detected:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rayon::prelude::*;

// Detected as parallel pipeline (is_parallel = true)
let results: Vec&lt;_&gt; = items.par_iter()
    .filter(|x| **x &gt; 0)
    .map(|x| x * 2)
    .collect();
<span class="boring">}</span></code></pre></pre>
<p>Parallel pipelines indicate high-performance functional patterns and receive positive quality scoring.</p>
<h3 id="builder-pattern-filtering"><a class="header" href="#builder-pattern-filtering">Builder Pattern Filtering</a></h3>
<p>To avoid false positives, debtmap distinguishes builder patterns from functional pipelines:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a builder pattern, NOT counted as a functional pipeline
let config = ConfigBuilder::new()
    .with_host("localhost")
    .with_port(8080)
    .build();

// This IS a functional pipeline
let values = items.iter()
    .map(|x| x * 2)
    .collect();
<span class="boring">}</span></code></pre></pre>
<p>Builder patterns are filtered out to ensure accurate functional composition metrics.</p>
<h2 id="purity-analysis"><a class="header" href="#purity-analysis">Purity Analysis</a></h2>
<p>Debtmap analyzes functions to determine their purity level - whether they have side effects and mutable state.</p>
<h3 id="purity-levels"><a class="header" href="#purity-levels">Purity Levels</a></h3>
<p>Functions are classified into three purity levels for god object weighting (defined in <code>src/organization/purity_analyzer.rs</code>):</p>
<blockquote>
<p><strong>Note:</strong> Debtmap has two purity analysis systems serving different purposes:</p>
<ol>
<li><strong>PurityLevel</strong> (three levels) - Used for god object scoring with weight multipliers (this section)</li>
<li><strong>PurityLevel</strong> (four levels) - Used in <code>src/analysis/purity_analysis.rs</code> for detailed responsibility classification (Strictly Pure, Locally Pure, Read-Only, Impure)</li>
</ol>
<p>This chapter focuses on the three-level system for god object integration.</p>
</blockquote>
<h4 id="pure-weight-03"><a class="header" href="#pure-weight-03">Pure (Weight 0.3)</a></h4>
<p>Guaranteed no side effects:</p>
<ul>
<li>No mutable parameters (<code>&amp;mut</code>, <code>mut self</code>)</li>
<li>No I/O operations</li>
<li>No global mutations</li>
<li>No <code>unsafe</code> blocks</li>
<li>Only immutable bindings</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pure function
fn calculate_total(items: &amp;[i32]) -&gt; i32 {
    items.iter().sum()
}

// Pure function with immutable bindings
fn process_value(x: i32) -&gt; i32 {
    let doubled = x * 2;  // Immutable binding
    let result = doubled + 10;
    result
}
<span class="boring">}</span></code></pre></pre>
<h4 id="probably-pure-weight-05"><a class="header" href="#probably-pure-weight-05">Probably Pure (Weight 0.5)</a></h4>
<p>Likely no side effects:</p>
<ul>
<li>Static functions (<code>fn</code> items, not methods)</li>
<li>Associated functions (no <code>self</code>)</li>
<li>No obvious side effects detected</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Probably pure - static function
fn transform(value: i32) -&gt; i32 {
    value * 2
}

// Probably pure - associated function
impl MyType {
    fn create_default() -&gt; Self {
        MyType { value: 0 }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="impure-weight-10"><a class="header" href="#impure-weight-10">Impure (Weight 1.0)</a></h4>
<p>Has side effects:</p>
<ul>
<li>Uses mutable references (<code>&amp;mut</code>, <code>mut self</code>)</li>
<li>Performs I/O operations (<code>println!</code>, file I/O, network)</li>
<li>Uses <code>async</code> (potential side effects)</li>
<li>Mutates global state</li>
<li>Uses <code>unsafe</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Impure - mutable reference
fn increment(value: &amp;mut i32) {
    *value += 1;
}

// Impure - I/O operation
fn log_value(value: i32) {
    println!("Value: {}", value);
}

// Impure - mutation
fn process_items(items: &amp;mut Vec&lt;i32&gt;) {
    items.push(42);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="purity-weight-multipliers"><a class="header" href="#purity-weight-multipliers">Purity Weight Multipliers</a></h3>
<p>Purity levels affect god object detection through weight multipliers (implemented in <code>src/organization/purity_analyzer.rs:29-39</code>). Pure functions contribute <strong>less</strong> to god object scores, rewarding codebases with many small pure helper functions:</p>
<ul>
<li><strong>Pure (0.3)</strong>: A pure function counts as 30% of a regular function in god object method count calculations</li>
<li><strong>Probably Pure (0.5)</strong>: Counts as 50%</li>
<li><strong>Impure (1.0)</strong>: Full weight</li>
</ul>
<p>The <code>purity_score</code> dampens god object scores via the <code>weight_multiplier</code> calculation. For example, pure functions with weight 0.3 count as only 30% of a regular function when calculating method counts for god object detection.</p>
<p><strong>Example</strong>: A module with 20 pure helper functions (20 × 0.3 = 6.0 effective) is less likely to trigger god object warnings than a module with 10 impure functions (10 × 1.0 = 10.0 effective).</p>
<h2 id="side-effect-detection"><a class="header" href="#side-effect-detection">Side Effect Detection</a></h2>
<h3 id="detected-side-effects"><a class="header" href="#detected-side-effects">Detected Side Effects</a></h3>
<p><strong>I/O Operations:</strong></p>
<ul>
<li>File reading/writing</li>
<li>Network calls</li>
<li>Console output</li>
<li>Database queries</li>
</ul>
<p><strong>State Mutation:</strong></p>
<ul>
<li>Mutable global variables</li>
<li>Shared mutable state</li>
<li>Reference mutations</li>
</ul>
<p><strong>Randomness:</strong></p>
<ul>
<li>Random number generation</li>
<li>Time-dependent behavior</li>
</ul>
<p><strong>System Interaction:</strong></p>
<ul>
<li>Environment variable access</li>
<li>System calls</li>
<li>Thread spawning</li>
</ul>
<h3 id="rust-specific-detection"><a class="header" href="#rust-specific-detection">Rust-Specific Detection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Interior mutability detection
use std::cell::RefCell;

fn has_side_effect() {
    let data = RefCell::new(vec![]);
    data.borrow_mut().push(1);  // Detected as mutation
}

// Unsafe code detection
fn unsafe_side_effect() {
    unsafe {
        // Automatically flagged as potentially impure
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="side-effect-classification"><a class="header" href="#side-effect-classification">Side Effect Classification</a></h3>
<p>Side effects are categorized by severity:</p>
<h4 id="pure---no-side-effects"><a class="header" href="#pure---no-side-effects">Pure - No Side Effects</a></h4>
<p>No mutations, I/O, or global state changes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pure - only computation
fn fibonacci(n: u32) -&gt; u32 {
    match n {
        0 =&gt; 0,
        1 =&gt; 1,
        _ =&gt; fibonacci(n - 1) + fibonacci(n - 2),
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="benign---small-penalty"><a class="header" href="#benign---small-penalty">Benign - Small Penalty</a></h4>
<p>Only logging, tracing, or metrics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::debug;

// Benign - logging side effect
fn process(value: i32) -&gt; i32 {
    debug!("Processing value: {}", value);
    value * 2
}
<span class="boring">}</span></code></pre></pre>
<p>Benign side effects receive a <strong>small penalty</strong> in purity scoring. Logging and observability are recognized as practical necessities.</p>
<h4 id="impure---large-penalty"><a class="header" href="#impure---large-penalty">Impure - Large Penalty</a></h4>
<p>I/O, mutations, network operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Impure - file I/O
fn save_to_file(data: &amp;str) -&gt; std::io::Result&lt;()&gt; {
    std::fs::write("output.txt", data)
}

// Impure - network operation
async fn fetch_data(url: &amp;str) -&gt; Result&lt;String, reqwest::Error&gt; {
    reqwest::get(url).await?.text().await
}
<span class="boring">}</span></code></pre></pre>
<p>Impure side effects receive a <strong>large penalty</strong> in purity scoring.</p>
<h3 id="purity-metrics"><a class="header" href="#purity-metrics">Purity Metrics</a></h3>
<p>For each function, debtmap calculates purity metrics through the functional composition analysis (<code>src/analysis/functional_composition.rs</code>). These metrics are computed by <code>analyze_composition()</code> and returned in <code>CompositionMetrics</code> and <code>PurityMetrics</code>:</p>
<ul>
<li><strong><code>has_mutable_state</code></strong> - Whether the function uses mutable bindings</li>
<li><strong><code>has_side_effects</code></strong> - Whether I/O or global mutations are detected</li>
<li><strong><code>immutability_ratio</code></strong> - Ratio of immutable to total bindings (0.0-1.0)</li>
<li><strong><code>is_const_fn</code></strong> - Whether declared as <code>const fn</code></li>
<li><strong><code>side_effect_kind</code></strong> - Classification: Pure, Benign, or Impure</li>
<li><strong><code>purity_score</code></strong> - Overall purity score (0.0 impure to 1.0 pure)</li>
</ul>
<h4 id="immutability-ratio"><a class="header" href="#immutability-ratio">Immutability Ratio</a></h4>
<p>The immutability ratio measures how much of a function’s local state is immutable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example() {
    let x = 10;         // Immutable
    let y = 20;         // Immutable
    let mut z = 30;     // Mutable
    z += 1;
    // immutability_ratio = 2/3 = 0.67
}
<span class="boring">}</span></code></pre></pre>
<p>Higher immutability ratios contribute to better purity scores.</p>
<h2 id="composition-pattern-recognition"><a class="header" href="#composition-pattern-recognition">Composition Pattern Recognition</a></h2>
<h3 id="function-composition"><a class="header" href="#function-composition">Function Composition</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Detected composition pattern
fn process_data(input: String) -&gt; Result&lt;Output&gt; {
    input
        .parse()
        .map(validate)
        .and_then(transform)
        .map(normalize)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-Order Functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Detected HOF pattern
fn apply_twice&lt;F&gt;(f: F, x: i32) -&gt; i32
where
    F: Fn(i32) -&gt; i32,
{
    f(f(x))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mapfilterfold-chains"><a class="header" href="#mapfilterfold-chains">Map/Filter/Fold Chains</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Detected functional pipeline
let result = items
    .iter()
    .filter(|x| x.is_valid())
    .map(|x| x.transform())
    .fold(0, |acc, x| acc + x);
<span class="boring">}</span></code></pre></pre>
<h2 id="composition-quality-scoring"><a class="header" href="#composition-quality-scoring">Composition Quality Scoring</a></h2>
<p>Debtmap combines pipeline metrics and purity analysis into an overall <strong>composition quality score</strong> (0.0-1.0).</p>
<h3 id="scoring-factors"><a class="header" href="#scoring-factors">Scoring Factors</a></h3>
<p>The composition quality score considers:</p>
<ol>
<li><strong>Pipeline depth</strong> - Longer pipelines indicate more functional composition</li>
<li><strong>Purity score</strong> - Higher purity means better functional programming</li>
<li><strong>Immutability ratio</strong> - More immutable bindings improve the score</li>
<li><strong>Closure complexity</strong> - Simpler closures score better</li>
<li><strong>Parallel execution</strong> - Parallel pipelines receive bonuses</li>
<li><strong>Nested pipelines</strong> - Sophisticated composition patterns score higher</li>
</ol>
<h3 id="quality-thresholds"><a class="header" href="#quality-thresholds">Quality Thresholds</a></h3>
<p>Based on your configuration profile, functions with composition quality above the threshold receive <strong>score boosts</strong> in debtmap’s overall analysis:</p>
<ul>
<li><strong>Strict</strong>: Quality ≥ 0.7 required for boost</li>
<li><strong>Balanced</strong>: Quality ≥ 0.6 required for boost</li>
<li><strong>Lenient</strong>: Quality ≥ 0.4 required for boost</li>
</ul>
<p>High-quality functional code can offset complexity in other areas of your codebase.</p>
<h3 id="purity-scoring"><a class="header" href="#purity-scoring">Purity Scoring</a></h3>
<h4 id="distribution-analysis"><a class="header" href="#distribution-analysis">Distribution Analysis</a></h4>
<p>Debtmap calculates purity distribution:</p>
<ul>
<li><strong>Pure functions</strong>: 0 side effects detected</li>
<li><strong>Mostly pure</strong>: Minor side effects (e.g., logging)</li>
<li><strong>Impure</strong>: Multiple side effects</li>
<li><strong>Highly impure</strong>: Extensive state mutation and I/O</li>
</ul>
<h4 id="scoring-formula"><a class="header" href="#scoring-formula">Scoring Formula</a></h4>
<pre><code>Purity Score = (pure_functions / total_functions) × 100
Side Effect Density = total_side_effects / total_functions
</code></pre>
<h4 id="codebase-health-metrics"><a class="header" href="#codebase-health-metrics">Codebase Health Metrics</a></h4>
<pre><code>Target Purity Levels:
- Core business logic: 80%+ pure
- Utilities: 70%+ pure
- I/O layer: 20-30% pure (expected)
- Overall: 50%+ pure
</code></pre>
<h3 id="integration-with-risk-scoring"><a class="header" href="#integration-with-risk-scoring">Integration with Risk Scoring</a></h3>
<p>Functional composition quality integrates with debtmap’s risk scoring system and multi-signal aggregation framework:</p>
<ul>
<li><strong>High composition quality</strong> → Lower risk scores (functions with quality above threshold receive score boosts)</li>
<li><strong>Pure functions</strong> → Reduced god object penalties (via weight multipliers in <code>purity_analyzer.rs</code>)</li>
<li><strong>Deep pipelines</strong> → Bonus for functional patterns</li>
<li><strong>Impure side effects</strong> → Risk penalties applied</li>
</ul>
<p><strong>Multi-Signal Integration</strong>: Functional composition analysis is one of several signals aggregated in the unified analysis system (<code>src/builders/unified_analysis.rs</code> and <code>src/analysis/multi_signal_aggregation.rs</code>) alongside complexity metrics, god object detection, and risk assessment. This ensures that functional programming quality contributes to the comprehensive technical debt assessment across multiple dimensions.</p>
<p>This integration ensures that well-written functional code is properly rewarded in the overall technical debt assessment.</p>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="example-1-detecting-imperative-vs-functional-code"><a class="header" href="#example-1-detecting-imperative-vs-functional-code">Example 1: Detecting Imperative vs Functional Code</a></h3>
<p><strong>Imperative style</strong> (lower composition quality):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_items_imperative(items: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    let mut results = Vec::new();
    for item in items {
        if item &gt; 0 {
            results.push(item * 2);
        }
    }
    results
}
// Detected: No pipelines, mutable state, lower purity score
<span class="boring">}</span></code></pre></pre>
<p><strong>Functional style</strong> (higher composition quality):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_items_functional(items: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    items.iter()
        .filter(|x| **x &gt; 0)
        .map(|x| x * 2)
        .collect()
}
// Detected: Pipeline depth 3, pure function, high composition quality
<span class="boring">}</span></code></pre></pre>
<h3 id="example-2-identifying-refactoring-opportunities"><a class="header" href="#example-2-identifying-refactoring-opportunities">Example 2: Identifying Refactoring Opportunities</a></h3>
<p>When debtmap detects low composition quality, it suggests refactoring:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Original: Imperative with mutations
fn calculate_statistics(data: &amp;[f64]) -&gt; (f64, f64, f64) {
    let mut sum = 0.0;
    let mut min = f64::MAX;
    let mut max = f64::MIN;

    for &amp;value in data {
        sum += value;
        if value &lt; min { min = value; }
        if value &gt; max { max = value; }
    }

    (sum / data.len() as f64, min, max)
}

// Refactored: Functional style
fn calculate_statistics_functional(data: &amp;[f64]) -&gt; (f64, f64, f64) {
    let sum: f64 = data.iter().sum();
    let min = data.iter().min_by(|a, b| a.partial_cmp(b).unwrap()).unwrap();
    let max = data.iter().max_by(|a, b| a.partial_cmp(b).unwrap()).unwrap();

    (sum / data.len() as f64, *min, *max)
}
// Higher purity score, multiple pipelines detected
<span class="boring">}</span></code></pre></pre>
<h3 id="example-3-using-profiles-for-different-codebases"><a class="header" href="#example-3-using-profiles-for-different-codebases">Example 3: Using Profiles for Different Codebases</a></h3>
<p><strong>Strict profile</strong> - Catches subtle functional patterns:</p>
<pre><code class="language-bash">$ debtmap analyze --ast-functional-analysis --functional-analysis-profile strict src/
# Detects pipelines with 3+ stages
# Requires purity ≥ 0.9 for "pure" classification
# Flags closures with complexity &gt; 3
</code></pre>
<p><strong>Balanced profile</strong> - Default for most projects:</p>
<pre><code class="language-bash">$ debtmap analyze --ast-functional-analysis --functional-analysis-profile balanced src/
# Detects pipelines with 2+ stages
# Requires purity ≥ 0.8 for "pure" classification
# Flags closures with complexity &gt; 5
</code></pre>
<p><strong>Lenient profile</strong> - For legacy code:</p>
<pre><code class="language-bash">$ debtmap analyze --ast-functional-analysis --functional-analysis-profile lenient src/
# Detects pipelines with 2+ stages
# Requires purity ≥ 0.5 for "pure" classification
# Flags closures with complexity &gt; 10
</code></pre>
<h3 id="example-4-interpreting-purity-scores"><a class="header" href="#example-4-interpreting-purity-scores">Example 4: Interpreting Purity Scores</a></h3>
<p><strong>Pure function</strong> (score: 1.0):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
// Purity: 1.0 (perfect)
// Immutability ratio: 1.0 (no bindings)
// Side effects: None
<span class="boring">}</span></code></pre></pre>
<p><strong>Mostly pure</strong> (score: 0.8):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process(values: &amp;[i32]) -&gt; i32 {
    let doubled: Vec&lt;_&gt; = values.iter().map(|x| x * 2).collect();
    let sum: i32 = doubled.iter().sum();
    sum
}
// Purity: 0.8 (high)
// Immutability ratio: 1.0 (both bindings immutable)
// Side effects: None
// Pipelines: 2 detected
<span class="boring">}</span></code></pre></pre>
<p><strong>Impure function</strong> (score: 0.2):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn log_and_process(values: &amp;mut Vec&lt;i32&gt;) {
    println!("Processing {} items", values.len());
    values.iter_mut().for_each(|x| *x *= 2);
}
// Purity: 0.2 (low)
// Immutability ratio: 0.0 (mutable parameter)
// Side effects: I/O (println), mutation
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="writing-functional-rust-code"><a class="header" href="#writing-functional-rust-code">Writing Functional Rust Code</a></h3>
<p>To achieve high composition quality scores:</p>
<ol>
<li>
<p><strong>Prefer iterator chains over manual loops</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good
let evens: Vec&lt;_&gt; = items.iter().filter(|x| *x % 2 == 0).collect();

// Avoid
let mut evens = Vec::new();
for item in &amp;items {
    if item % 2 == 0 { evens.push(item); }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Minimize mutable state</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good
let result = calculate(input);

// Avoid
let mut result = 0;
result = calculate(input);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Separate pure logic from side effects</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good - pure computation
fn calculate_price(quantity: u32, unit_price: f64) -&gt; f64 {
    quantity as f64 * unit_price
}

// Good - I/O at the boundary
fn display_price(price: f64) {
    println!("Total: ${:.2}", price);
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Keep closures simple</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good - simple closure
items.map(|x| x * 2)

// Consider extracting - complex closure
items.map(|x| {
    let temp = expensive_operation(x);
    transform(temp)
})

// Better
fn transform_item(x: i32) -&gt; i32 {
    let temp = expensive_operation(x);
    transform(temp)
}
items.map(transform_item)
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Use parallel iteration for CPU-intensive work</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rayon::prelude::*;

let results: Vec&lt;_&gt; = large_dataset.par_iter()
    .map(|item| expensive_computation(item))
    .collect();
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="code-organization"><a class="header" href="#code-organization">Code Organization</a></h3>
<p><strong>Separate pure from impure:</strong></p>
<ul>
<li>Keep pure logic in core modules</li>
<li>Isolate I/O at boundaries</li>
<li>Use dependency injection for testability</li>
</ul>
<p><strong>Maximize purity in:</strong></p>
<ul>
<li>Business logic</li>
<li>Calculations and transformations</li>
<li>Validation functions</li>
<li>Data structure operations</li>
</ul>
<p><strong>Accept impurity in:</strong></p>
<ul>
<li>I/O layers</li>
<li>Logging and monitoring</li>
<li>External system integration</li>
<li>Application boundaries</li>
</ul>
<p><strong>Refactoring strategy:</strong></p>
<ol>
<li>Identify impure functions</li>
<li>Extract pure logic</li>
<li>Push side effects to boundaries</li>
<li>Test pure functions exhaustively</li>
</ol>
<h3 id="migration-guide"><a class="header" href="#migration-guide">Migration Guide</a></h3>
<p>To enable functional analysis on existing projects:</p>
<ol>
<li>
<p><strong>Start with lenient profile</strong> to understand current state:</p>
<pre><code class="language-bash">debtmap analyze --ast-functional-analysis --functional-analysis-profile lenient .
</code></pre>
</li>
<li>
<p><strong>Identify quick wins</strong> - functions that are almost functional:</p>
<ul>
<li>Look for loops that can become iterator chains</li>
<li>Find mutable variables that can be immutable</li>
<li>Spot side effects that can be extracted</li>
</ul>
</li>
<li>
<p><strong>Gradually refactor</strong> to functional patterns:</p>
<ul>
<li>Convert one function at a time</li>
<li>Run tests after each change</li>
<li>Measure improvements with debtmap</li>
</ul>
</li>
<li>
<p><strong>Tighten profile</strong> as codebase improves:</p>
<pre><code class="language-bash"># After refactoring
debtmap analyze --ast-functional-analysis --functional-analysis-profile balanced .

# For new modules
debtmap analyze --ast-functional-analysis --functional-analysis-profile strict src/new_module/
</code></pre>
</li>
<li>
<p><strong>Monitor composition quality trends</strong> over time</p>
</li>
</ol>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="code-quality-audit"><a class="header" href="#code-quality-audit">Code Quality Audit</a></h3>
<pre><code class="language-bash"># Assess functional purity
debtmap analyze . --ast-functional-analysis --functional-analysis-profile balanced --format markdown
</code></pre>
<h3 id="refactoring-targets"><a class="header" href="#refactoring-targets">Refactoring Targets</a></h3>
<pre><code class="language-bash"># Find impure functions in core logic
debtmap analyze src/core/ --ast-functional-analysis --functional-analysis-profile strict
</code></pre>
<h3 id="onboarding-guide"><a class="header" href="#onboarding-guide">Onboarding Guide</a></h3>
<pre><code class="language-bash"># Show functional patterns in codebase
debtmap analyze . --ast-functional-analysis --functional-analysis-profile balanced --summary
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="no-pipelines-detected-but-i-have-iterator-chains"><a class="header" href="#no-pipelines-detected-but-i-have-iterator-chains">“No pipelines detected” but I have iterator chains</a></h3>
<ul>
<li><strong>Check pipeline depth</strong>: Your chains may be too short for the profile
<ul>
<li>Strict requires 3+ stages</li>
<li>Balanced/Lenient require 2+ stages</li>
</ul>
</li>
<li><strong>Check for builder patterns</strong>: Method chaining for construction is filtered out</li>
<li><strong>Verify terminal operation</strong>: Ensure the chain ends with <code>collect()</code>, <code>sum()</code>, etc.</li>
</ul>
<h3 id="low-purity-score-for-seemingly-pure-functions"><a class="header" href="#low-purity-score-for-seemingly-pure-functions">“Low purity score” for seemingly pure functions</a></h3>
<ul>
<li><strong>Check for hidden side effects</strong>:
<ul>
<li><code>println!</code> or logging statements</li>
<li>Calls to impure helper functions</li>
<li><code>unsafe</code> blocks</li>
</ul>
</li>
<li><strong>Review immutability ratio</strong>: Unnecessary <code>mut</code> bindings lower the score</li>
<li><strong>Verify no I/O operations</strong>: File access, network calls affect purity</li>
</ul>
<h3 id="high-complexity-closures-flagged"><a class="header" href="#high-complexity-closures-flagged">“High complexity closures flagged”</a></h3>
<ul>
<li><strong>Extract complex closures</strong> into named functions:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of
items.map(|x| { /* 10 lines */ })

// Use
fn process_item(x: Item) -&gt; Result { /* 10 lines */ }
items.map(process_item)
<span class="boring">}</span></code></pre></pre>
</li>
<li><strong>Adjust <code>max_closure_complexity</code></strong>: Consider lenient profile if needed</li>
<li><strong>Refactor closure logic</strong>: Break down complex operations</li>
</ul>
<h3 id="too-many-false-positives"><a class="header" href="#too-many-false-positives">Too Many False Positives</a></h3>
<p><strong>Issue:</strong> Pure functions flagged as impure</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Use lenient profile</li>
<li>Suppress known patterns</li>
<li>Review detection criteria</li>
<li>Report false positives</li>
</ul>
<h3 id="missing-side-effects"><a class="header" href="#missing-side-effects">Missing Side Effects</a></h3>
<p><strong>Issue:</strong> Known impure functions not detected</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Use strict profile</li>
<li>Check for exotic side effect patterns</li>
<li>Enable comprehensive analysis</li>
</ul>
<h3 id="performance-impact-concerns"><a class="header" href="#performance-impact-concerns">Performance impact concerns</a></h3>
<ul>
<li><strong>Spec 111 targets &lt;10% overhead</strong>: Performance impact should be minimal</li>
<li><strong>Disable for hot paths</strong>: Analyze functional patterns in separate runs if needed</li>
<li><strong>Use caching</strong>: Debtmap caches analysis results between runs</li>
</ul>
<h2 id="related-chapters"><a class="header" href="#related-chapters">Related Chapters</a></h2>
<ul>
<li><a href="analysis-guide.html">Analysis Guide</a> - Understanding analysis types</li>
<li><a href="./complexity-analysis.html">Complexity Analysis</a> - How functional patterns affect complexity metrics</li>
<li><a href="./scoring.html">Scoring Strategies</a> - Integration with overall technical debt scoring</li>
<li><a href="./god-objects.html">God Object Detection</a> - How purity weights reduce false positives</li>
<li><a href="./configuration.html">Configuration</a> - Advanced functional analysis configuration options</li>
<li><a href="refactoring-guide.html">Refactoring</a> - Extracting pure functions</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Functional composition analysis helps you:</p>
<ul>
<li><strong>Identify functional patterns</strong> in your Rust codebase through AST-based pipeline detection</li>
<li><strong>Measure purity</strong> with side effect detection and immutability analysis</li>
<li><strong>Improve code quality</strong> by refactoring imperative code to functional style</li>
<li><strong>Get scoring benefits</strong> for high-quality functional programming patterns</li>
<li><strong>Choose appropriate profiles</strong> (strict/balanced/lenient) for different codebases</li>
</ul>
<p>Enable it with <code>--functional-analysis-profile</code> to start benefiting from functional programming insights in your technical debt analysis.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="error-handling-analysis.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="god-object-detection.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="error-handling-analysis.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="god-object-detection.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
