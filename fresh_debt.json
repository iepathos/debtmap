============================================
    Debtmap v0.2.3
============================================

[TARGET] TOP 10 RECOMMENDATIONS

#1 SCORE: 160 [CRITICAL - FILE - GOD MODULE]
â””â”€ ./src/complexity/languages/python.rs (2704 lines, 157 functions)
â””â”€ WHY: This module contains 157 functions in a single file, violating module cohesion principles. Large procedural modules are difficult to navigate, understand, and maintain.
â””â”€ ACTION: URGENT: 2704 lines, 157 functions! Split by data flow: 1) Input/parsing functions 2) Core logic/transformation 3) Output/formatting. Create 6 focused modules with <30 functions each.
  - 1. Run `grep -n "^pub fn\|^fn" ./src/complexity/languages/python.rs` to list all functions
  - 2. Group functions by: a) AST node types they handle b) similar prefixes c) data flow patterns
  - 3. Create new files: `python_core.rs`, `python_io.rs`, `python_utils.rs` (adjust names to match groups)
  - 4. Move functions in groups of 10-20, test after each move
  - 5. DO NOT: Try to fix everything at once. Move incrementally, test frequently
â””â”€ IMPACT: Reduce complexity by 80%, improve testability, enable parallel development
â””â”€ METRICS: Methods: 80, Fields: 1, Responsibilities: 3
â””â”€ SCORING: File size: CRITICAL | Functions: EXCESSIVE | Complexity: HIGH
â””â”€ DEPENDENCIES: 157 functions may have complex interdependencies

#2 SCORE: 82.7 [LOW - FILE AGGREGATE]
â”œâ”€ ./src/cache/shared_cache.rs (15 functions, total score: 123.1)
â”œâ”€ WHY: File aggregate combines complexity scores from 15 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 11 functions exceed complexity thresholds.
â”œâ”€ ACTION: Fix ONLY the top 2 functions listed below. DO NOT refactor the entire file. Focus on functions with complexity > 10 or coverage < 60%
â”‚  â”œâ”€ 1. Fix ONLY these 2 functions (listed in DEPENDENCIES below)
â”‚  â”œâ”€ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
â”‚  â”œâ”€ 3. For each function: If complexity > 10, apply these patterns:
â”‚  â”‚   â€¢ Extract guard clauses: Convert nested if-else to early returns
â”‚  â”‚   â€¢ Extract validation: Move input checks to separate function
â”‚  â”‚   â€¢ Replace conditionals with map/filter when processing collections
â”‚  â”‚   â€¢ Extract complex boolean expressions into named predicates
â”‚  â””â”€ 4. DO NOT: Create new files, add abstraction layers, or refactor working code
â”œâ”€ IMPACT: Reduce overall file complexity by 73%, improve test coverage, enable safer refactoring
â”œâ”€ METRICS: Functions: 15, Problematic: 11, Avg complexity: 8.2
â”œâ”€ SCORING: Aggregate: LOW | Avg per function: 5.5 | Max: 24.1
â””â”€ DEPS: 11 high-complexity functions identified
   â”œâ”€ SharedCache::trigger_pruning: 24.1
   â”œâ”€ SharedCache::clear_project: 12.7
   â”œâ”€ SharedCache::retry_with_backoff: 12.1
   â”œâ”€ SharedCache::put_with_config: 11.2
   â””â”€ SharedCache::trigger_pruning_if_needed_with_new_entry: 8.2

#3 SCORE: 72.3 [CRITICAL - FILE - GOD MODULE]
â””â”€ ./src/io/writers/markdown.rs (1870 lines, 87 functions)
â””â”€ WHY: This module contains 87 functions in a single file, violating module cohesion principles. Large procedural modules are difficult to navigate, understand, and maintain.
â””â”€ ACTION: URGENT: 1870 lines, 87 functions! Split by data flow: 1) Input/parsing functions 2) Core logic/transformation 3) Output/formatting. Create 3 focused modules with <30 functions each.
  - 1. Run `grep -n "^pub fn\|^fn" ./src/io/writers/markdown.rs` to list all functions
  - 2. Group functions by: a) AST node types they handle b) similar prefixes c) data flow patterns
  - 3. Create new files: `markdown_core.rs`, `markdown_io.rs`, `markdown_utils.rs` (adjust names to match groups)
  - 4. Move functions in groups of 10-20, test after each move
  - 5. DO NOT: Try to fix everything at once. Move incrementally, test frequently
â””â”€ IMPACT: Reduce complexity by 80%, improve testability, enable parallel development
â””â”€ METRICS: Methods: 57, Fields: 2, Responsibilities: 3
â””â”€ SCORING: File size: CRITICAL | Functions: EXCESSIVE | Complexity: HIGH
â””â”€ DEPENDENCIES: 87 functions may have complex interdependencies

#4 SCORE: 68.2 [LOW - FILE AGGREGATE]
â”œâ”€ ./src/io/writers/enhanced_markdown/mod.rs (20 functions, total score: 109.0)
â”œâ”€ WHY: File aggregate combines complexity scores from 20 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 8 functions exceed complexity thresholds.
â”œâ”€ ACTION: Fix ONLY the top 2 functions listed below. DO NOT refactor the entire file. Focus on functions with complexity > 10 or coverage < 60%
â”‚  â”œâ”€ 1. Fix ONLY these 2 functions (listed in DEPENDENCIES below)
â”‚  â”œâ”€ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
â”‚  â”œâ”€ 3. For each function: If complexity > 10, apply these patterns:
â”‚  â”‚   â€¢ Extract guard clauses: Convert nested if-else to early returns
â”‚  â”‚   â€¢ Extract validation: Move input checks to separate function
â”‚  â”‚   â€¢ Replace conditionals with map/filter when processing collections
â”‚  â”‚   â€¢ Extract complex boolean expressions into named predicates
â”‚  â””â”€ 4. DO NOT: Create new files, add abstraction layers, or refactor working code
â”œâ”€ IMPACT: Reduce overall file complexity by 40%, improve test coverage, enable safer refactoring
â”œâ”€ METRICS: Functions: 20, Problematic: 8, Avg complexity: 5.4
â”œâ”€ SCORING: Aggregate: LOW | Avg per function: 3.4 | Max: 18.7
â””â”€ DEPS: 8 high-complexity functions identified
   â”œâ”€ EnhancedMarkdownWriter::write_executive_summary: 18.7
   â”œâ”€ EnhancedMarkdownWriter::write_recommendations: 10.0
   â”œâ”€ EnhancedMarkdownWriter::write_enhanced_report: 6.1
   â”œâ”€ EnhancedMarkdownWriter::write_complexity_hotspots: 6.0
   â””â”€ EnhancedMarkdownWriter::write_risk_analysis: 5.7

#5 SCORE: 60.8 [CRITICAL - FILE - GOD MODULE]
â””â”€ ./src/priority/scoring/debt_item.rs (2114 lines, 74 functions)
â””â”€ WHY: This module contains 74 functions in a single file, violating module cohesion principles. Large procedural modules are difficult to navigate, understand, and maintain.
â””â”€ ACTION: URGENT: 2114 lines, 74 functions! Split by data flow: 1) Input/parsing functions 2) Core logic/transformation 3) Output/formatting. Create 3 focused modules with <30 functions each.
  - 1. Run `grep -n "^pub fn\|^fn" ./src/priority/scoring/debt_item.rs` to list all functions
  - 2. Group functions by: a) AST node types they handle b) similar prefixes c) data flow patterns
  - 3. Create new files: `debt_item_core.rs`, `debt_item_io.rs`, `debt_item_utils.rs` (adjust names to match groups)
  - 4. Move functions in groups of 10-20, test after each move
  - 5. DO NOT: Try to fix everything at once. Move incrementally, test frequently
â””â”€ IMPACT: Reduce complexity by 80%, improve testability, enable parallel development
â””â”€ METRICS: Methods: 70, Fields: 0, Responsibilities: 4
â””â”€ SCORING: File size: CRITICAL | Functions: EXCESSIVE | Complexity: HIGH
â””â”€ DEPENDENCIES: 74 functions may have complex interdependencies

#6 SCORE: 34.8 [ðŸ”´ UNTESTED] [CRITICAL]
- LOCATION: ./src/priority/formatter.rs:697 format_priority_item()
- WHY: Complexity 11 is manageable. Coverage at 0%. Focus on test coverage, not refactoring
- ACTION: Add 11 tests for 100% coverage gap. NO refactoring needed (complexity 11 is acceptable)
   - 1. Write 11 focused tests for uncovered branches
   - 2. Each test should be <15 lines and test ONE path
   - 3. IF nesting > 3: Use early returns with ? operator
   - 4. DO NOT extract functions unless there's clear duplication
- IMPACT: -5 complexity, -16.2 risk
- COMPLEXITY: cyclomatic=11 (adj:5), branches=11, cognitive=17, nesting=3, entropy=0.44
- DEPENDENCIES: 1 upstream, 7 downstream
   - CALLERS: format_tail
   - CALLS: get_severity_color, extract_dependency_info, format_visibility, ... (4 more)

#7 SCORE: 34.3 [ðŸ”´ UNTESTED] [CRITICAL]
- LOCATION: ./src/analysis/diagnostics/reporter.rs:23 DiagnosticReporter::generate_report()
- WHY: Complexity 7 is manageable. Coverage at 0%. Focus on test coverage, not refactoring
- ACTION: Add 7 tests for 100% coverage gap. NO refactoring needed (complexity 7 is acceptable)
   - 1. Write 7 focused tests for uncovered branches
   - 2. Each test should be <15 lines and test ONE path
   - 3. DO NOT refactor - current structure is fine
   - 4. Focus on test coverage only
- IMPACT: -3 complexity, -9.8 risk
- COMPLEXITY: cyclomatic=7 (adj:3), branches=7, cognitive=8, nesting=1, entropy=0.31
- DEPENDENCIES: 6 upstream, 5 downstream
   - CALLERS: tests::test_format_json, tests::test_generate_report_summary_level, tests::test_generate_report_debug_level, ... (3 more)
   - CALLS: generate_detailed_attribution, DetailLevel::includes_attribution, DetailLevel::includes_recommendations, ... (2 more)

#8 SCORE: 30.0 [ðŸ”´ UNTESTED] [CRITICAL]
- LOCATION: ./src/priority/formatter_markdown.rs:271 format_priority_item_markdown()
- WHY: Complexity 10 is manageable. Coverage at 0%. Focus on test coverage, not refactoring
- ACTION: Add 10 tests for 100% coverage gap. NO refactoring needed (complexity 10 is acceptable)
   - 1. Write 10 focused tests for uncovered branches
   - 2. Each test should be <15 lines and test ONE path
   - 3. DO NOT refactor - current structure is fine
   - 4. Focus on test coverage only
- IMPACT: -5 complexity, -16.2 risk
- COMPLEXITY: cyclomatic=10 (adj:5), branches=10, cognitive=17, nesting=3, entropy=0.36
- DEPENDENCIES: 1 upstream, 8 downstream
   - CALLERS: format_mixed_priority_item_markdown
   - CALLS: get_severity_label, extract_complexity_info, format_score_breakdown_with_coverage, ... (5 more)

#9 SCORE: 28.4 [ðŸ”´ UNTESTED] [CRITICAL]
- LOCATION: ./src/priority/formatter.rs:448 format_file_priority_item()
- WHY: Moderate complexity (20), needs functional decomposition
- ACTION: Apply functional patterns: 4 pure functions with Iterator chains
   - 1. Extract pure functions for each logical operation:
   - 2.   â€¢ Predicates: is_valid(), should_process()
   - 3.   â€¢ Transformations: map_to_domain(), normalize()
   - 4.   â€¢ Aggregations: fold(), collect_results()
   - 5. Use Iterator methods instead of loops:
   - 6.   â€¢ filter() instead of if statements in loops
   - 7.   â€¢ map() for transformations
   - 8.   â€¢ fold() or reduce() for aggregations
   - 9.   â€¢ partition() for splitting collections
   - 10. Use property-based testing to verify function invariants
- IMPACT: -10 complexity, -17.1 risk
- COMPLEXITY: cyclomatic=20 (adj:10), branches=20, cognitive=29, nesting=2, entropy=0.43
- DEPENDENCIES: 1 upstream, 2 downstream
   - CALLERS: format_mixed_priority_item
   - CALLS: get_severity_color, get_severity_label

#10 SCORE: 23.9 [ðŸ”´ UNTESTED] [CRITICAL]
- LOCATION: ./src/priority/formatter.rs:272 format_file_aggregate_item()
- WHY: Complexity 13 is manageable. Coverage at 0%. Focus on test coverage, not refactoring
- ACTION: Add 13 tests for 100% coverage gap. NO refactoring needed (complexity 13 is acceptable)
   - 1. Write 13 focused tests for uncovered branches
   - 2. Each test should be <15 lines and test ONE path
   - 3. IF nesting > 3: Use early returns with ? operator
   - 4. DO NOT extract functions unless there's clear duplication
- IMPACT: -6 complexity, -16.4 risk
- COMPLEXITY: cyclomatic=13 (adj:6), branches=13, cognitive=16, nesting=3, entropy=0.53
- DEPENDENCIES: 1 upstream, 2 downstream
   - CALLERS: format_mixed_priority_item
   - CALLS: DebtItem::score, get_severity_color

[STATS] TOTAL DEBT SCORE: 2559
