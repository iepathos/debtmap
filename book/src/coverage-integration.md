# Coverage Integration

Coverage integration is one of Debtmap's most powerful capabilities, enabling **risk-based prioritization** by correlating complexity metrics with test coverage. This helps you identify truly risky code—functions that are both complex and untested—rather than just highlighting complex but well-tested functions.

## Why Coverage Matters

Without coverage data, complexity analysis shows you *what's complex*, but not *what's risky*. A complex function with 100% test coverage poses far less risk than a simple function with 0% coverage on a critical path.

Coverage integration transforms Debtmap from a complexity analyzer into a **risk assessment tool**:

- **Prioritize testing efforts**: Focus on high-complexity functions with low coverage
- **Validate refactoring safety**: See which complex code is already protected by tests
- **Risk-based sprint planning**: Surface truly risky code ahead of well-tested complexity
- **Quantify risk reduction**: Measure how coverage improvements reduce project risk

## LCOV Format: The Universal Standard

Debtmap uses the **LCOV format** for coverage data. LCOV is a language-agnostic standard supported by virtually all coverage tools across all major languages.

### Why LCOV?

- **Universal compatibility**: Works with Rust, Python, JavaScript, TypeScript, Go, and more
- **Tool independence**: Not tied to any specific test framework
- **Simple text format**: Easy to inspect and debug
- **Widely supported**: Generated by most modern coverage tools

### LCOV File Structure

An LCOV file contains line-by-line coverage information:

```lcov
SF:src/analyzer.rs
FN:42,calculate_complexity
FNDA:15,calculate_complexity
DA:42,15
DA:43,15
DA:44,12
DA:45,0
LH:3
LF:4
end_of_record
```

- `SF:` - Source file path
- `FN:` - Function name and starting line
- `FNDA:` - Function execution count
- `DA:` - Line execution data (line number, hit count)
- `LH:` - Lines hit
- `LF:` - Lines found (total)

## Generating Coverage Data

### Rust: cargo-tarpaulin

**Installation:**
```bash
cargo install cargo-tarpaulin
```

**Generate LCOV:**
```bash
cargo tarpaulin --out lcov --output-dir target/coverage
```

**Analyze with Debtmap:**
```bash
debtmap analyze . --lcov target/coverage/lcov.info
```

**Common Issues:**
- Ensure tests compile before running tarpaulin
- Use `--ignore-tests` if tests themselves show up in coverage
- Check paths match your project structure (relative to project root)

### JavaScript/TypeScript: Jest

**Configuration (package.json or jest.config.js):**
```json
{
  "jest": {
    "coverageReporters": ["lcov", "text"]
  }
}
```

**Generate Coverage:**
```bash
npm test -- --coverage
```

**Analyze with Debtmap:**
```bash
debtmap analyze . --lcov coverage/lcov.info
```

### Python: pytest-cov

**Installation:**
```bash
pip install pytest-cov
```

**Generate LCOV:**
```bash
pytest --cov=src --cov-report=lcov
```

**Analyze with Debtmap:**
```bash
debtmap analyze . --lcov coverage.lcov
```

### Go: go test with gocover-cobertura

**Generate Coverage:**
```bash
go test -coverprofile=coverage.out ./...
gocover-cobertura < coverage.out > coverage.xml
# Convert to LCOV using lcov tools
```

**Note**: Go's native coverage format requires conversion. Most CI systems support LCOV conversion plugins.

## How Coverage Affects Scoring

Coverage data impacts Debtmap's unified scoring system in two ways: the **coverage factor** and **coverage dampening**.

### Coverage Factor (40% Weight)

The coverage factor contributes **40%** to the unified debt score:

```
Coverage Factor = 10 × (1 - coverage_percentage) × complexity_weight
```

**Examples:**
- 0% coverage → Factor = 10.0 (maximum penalty)
- 50% coverage → Factor = 5.0 (moderate penalty)
- 100% coverage → Factor = 0.0 (no penalty)

**Special Cases:**
- **Test functions**: Coverage factor = 0 (tests don't need their own coverage)
- **No coverage data**: Assumes worst case (factor = 10.0)
- **Entry points**: Weighted at 0.6x (entry points naturally have low coverage)

### Coverage Dampening (Score Multiplier)

After base scores are calculated, coverage *dampens* the final debt score:

```
Final Score = Base Score × (1.0 - coverage_percentage)
```

**Examples:**

| Base Score | Coverage | Multiplier | Final Score | Priority |
|-----------|----------|------------|-------------|----------|
| 8.5 | 100% | 0.0 | 0.0 | Minimal (well-tested) |
| 8.5 | 50% | 0.5 | 4.25 | Medium |
| 8.5 | 0% | 1.0 | 8.5 | High (untested) |

**Key Insight**: Complex but well-tested code automatically drops in priority, while untested complex code rises to the top.

**Invariant**: Total debt score with coverage ≤ total debt score without coverage.

## Transitive Coverage Propagation

Debtmap doesn't just look at *direct* coverage—it propagates coverage through the **call graph** using transitive analysis.

### How It Works

A function's effective coverage considers:
1. **Direct coverage**: Lines executed by tests
2. **Caller coverage**: Coverage of functions that call this function

```
Transitive Coverage = Direct Coverage + Σ(Caller Coverage × Weight)
```

### Why It Matters

A function with 0% direct coverage might have high transitive coverage if it's only called by well-tested functions:

```rust
// direct_coverage = 0%
// But called only by `process_request` (100% coverage)
// → transitive_coverage = 85%
fn validate_input(data: &str) -> bool {
    data.len() > 0
}

// direct_coverage = 100%
fn process_request(input: String) -> Result<()> {
    if !validate_input(&input) {
        return Err("Invalid");
    }
    // ...
}
```

**Effect**: `validate_input` has reduced urgency because it's only reachable through well-tested code paths.

## Performance Characteristics

Coverage integration is highly optimized for large codebases:

- **Index Build**: O(n), ~20-30ms for 5,000 functions
- **Exact Lookup**: O(1), ~0.5μs per lookup
- **Fallback Lookup**: O(log n), ~5-8μs when exact match fails
- **Memory Usage**: ~200 bytes per record (~2MB for 5,000 functions)
- **Thread Safety**: Lock-free parallel access via `Arc<CoverageIndex>`
- **Analysis Overhead**: ~2.5x baseline (target: ≤3x)

**Result**: Coverage integration adds minimal overhead even on projects with thousands of functions.

## CLI Options Reference

### Primary Coverage Options

```bash
# Provide LCOV coverage file
debtmap analyze . --coverage-file path/to/lcov.info

# Shorthand alias
debtmap analyze . --lcov path/to/lcov.info
```

### Context Providers

Coverage can be combined with other context providers for nuanced risk assessment:

```bash
# Enable all context providers (includes coverage propagation)
debtmap analyze . --lcov coverage.info --enable-context

# Specify specific providers
debtmap analyze . --lcov coverage.info \
  --context-providers critical_path,dependency,git_history

# Disable specific providers
debtmap analyze . --lcov coverage.info \
  --disable-context git_history
```

**Available Context Providers**:
- `critical_path`: Identifies functions on critical execution paths
- `dependency`: Analyzes dependency relationships and impact
- `git_history`: Uses change frequency from version control

See [Scoring Strategies](scoring-strategies.md) for details on how these combine.

### Validate Command Support

The `validate` command also supports coverage integration for risk-based quality gates:

```bash
# Fail CI builds if untested complex code exceeds thresholds
debtmap validate . --lcov coverage.info --max-debt-density 50
```

See [CLI Reference](cli-reference.md) for complete validation options.

## Troubleshooting Coverage Integration

### Coverage Not Correlating with Functions

**Symptoms**:
- Debtmap shows 0% coverage for all functions
- Warning: "No coverage data correlated with analyzed functions"

**Solutions**:

1. **Verify LCOV Format**:
```bash
head coverage.info
# Should show: SF:, FN:, DA: lines
```

2. **Check Path Matching**:
Coverage file paths must be relative to project root:
```bash
# Good: SF:src/analyzer.rs
# Bad:  SF:/home/user/project/src/analyzer.rs
```

3. **Enable Verbose Logging**:
```bash
debtmap analyze . --lcov coverage.info -vv
```
This shows coverage lookup details for each function.

4. **Verify Coverage Tool Output**:
```bash
# Ensure your coverage tool generated line data (DA: records)
grep "^DA:" coverage.info | head
```

### Functions Still Show Up Despite 100% Coverage

**This is expected behavior** when:
- Function has high complexity (cyclomatic > 10)
- Function has other debt issues (duplication, nesting, etc.)
- You're viewing function-level output (coverage dampens but doesn't eliminate)

**Coverage reduces priority but doesn't hide issues**. Use filters to focus:
```bash
# Show only critical and high priority items
debtmap analyze . --lcov coverage.info --min-priority high

# Show top 10 most urgent items
debtmap analyze . --lcov coverage.info --top 10
```

### Coverage File Path Issues

**Problem**: Can't find coverage file

**Solutions**:
```bash
# Use absolute path
debtmap analyze . --lcov /absolute/path/to/coverage.info

# Or ensure relative path is from project root
debtmap analyze . --lcov ./target/coverage/lcov.info
```

### LCOV Format Errors

**Problem**: "Invalid LCOV format" error

**Causes**:
- Non-LCOV format (Cobertura XML, JaCoCo, etc.)
- Corrupted file
- Wrong file encoding

**Solutions**:
- Verify your coverage tool is configured for LCOV output
- Check for binary/encoding issues: `file coverage.info`
- Regenerate coverage with explicit LCOV format flag

See [Troubleshooting](troubleshooting.md) for more debugging tips.

## Best Practices

### Analysis Workflow

1. **Generate Coverage Before Analysis**:
   ```bash
   # Rust example
   cargo tarpaulin --out lcov --output-dir target/coverage
   debtmap analyze . --lcov target/coverage/lcov.info
   ```

2. **Use Coverage for Sprint Planning**:
   ```bash
   # Focus on untested complex code
   debtmap analyze . --lcov coverage.info --top 20
   ```

3. **Combine with Tiered Prioritization**:
   Coverage automatically feeds into [Tiered Prioritization](tiered-prioritization.md):
   - **Tier 1**: Architectural issues (less affected by coverage)
   - **Tier 2**: Complex untested code (coverage < 50%, complexity > 15)
   - **Tier 3**: Testing gaps (coverage < 80%, complexity 10-15)

4. **Validate Refactoring Impact**:
   ```bash
   # Before refactoring
   debtmap analyze . --lcov coverage-before.info -o before.json

   # After refactoring
   debtmap analyze . --lcov coverage-after.info -o after.json

   # Compare
   debtmap compare --before before.json --after after.json
   ```

### Testing Strategy

**Prioritize testing based on risk**:

1. **High Complexity + Low Coverage = Highest Priority**:
   ```bash
   debtmap analyze . --lcov coverage.info \
     --filter Risk --min-priority high
   ```

2. **Focus on Business Logic**:
   Entry points and infrastructure code have natural coverage patterns. Focus unit tests on business logic functions.

3. **Use Dependency Analysis**:
   ```bash
   debtmap analyze . --lcov coverage.info \
     --context-providers dependency -vv
   ```
   Tests high-dependency functions first—they have the most impact.

4. **Don't Over-Test Entry Points**:
   Entry points (main, handlers) are better tested with integration tests, not unit tests. Debtmap weights their coverage factor at 0.6x to account for this.

### Configuration

In `.debtmap.toml`:

```toml
[scoring]
# Adjust coverage weight if your project prioritizes coverage differently
coverage = 0.40  # Default: 40%
complexity = 0.40
dependency = 0.20

[thresholds]
# Set minimum risk score to filter low-priority items
minimum_risk_score = 15.0

# Skip simple functions even if uncovered
minimum_cyclomatic_complexity = 5
```

See [Configuration](configuration.md) for complete options.

### CI Integration

**Example GitHub Actions Workflow**:

```yaml
- name: Generate Coverage
  run: cargo tarpaulin --out lcov --output-dir target/coverage

- name: Analyze with Debtmap
  run: |
    debtmap analyze . \
      --lcov target/coverage/lcov.info \
      --format json \
      --output debtmap-report.json

- name: Validate Quality Gates
  run: |
    debtmap validate . \
      --lcov target/coverage/lcov.info \
      --max-debt-density 50
```

**Quality Gate Strategy**:
- Fail builds on new critical debt (Tier 1 architectural issues)
- Warn on new high-priority untested code (Tier 2)
- Track coverage trends over time with `compare` command

## Complete Language Examples

### Rust End-to-End

```bash
# 1. Generate coverage
cargo tarpaulin --out lcov --output-dir target/coverage

# 2. Verify LCOV output
head target/coverage/lcov.info

# 3. Run Debtmap with coverage
debtmap analyze . --lcov target/coverage/lcov.info

# 4. Interpret results (look for [UNTESTED] markers on high-complexity functions)
```

### JavaScript/TypeScript End-to-End

```bash
# 1. Configure Jest for LCOV (in package.json or jest.config.js)
# "coverageReporters": ["lcov", "text"]

# 2. Generate coverage
npm test -- --coverage

# 3. Verify LCOV output
head coverage/lcov.info

# 4. Run Debtmap
debtmap analyze . --lcov coverage/lcov.info --languages javascript,typescript
```

### Python End-to-End

```bash
# 1. Install pytest-cov
pip install pytest-cov

# 2. Generate LCOV coverage
pytest --cov=src --cov-report=lcov

# 3. Verify output
head coverage.lcov

# 4. Run Debtmap
debtmap analyze . --lcov coverage.lcov --languages python
```

### Go End-to-End

```bash
# 1. Generate native coverage
go test -coverprofile=coverage.out ./...

# 2. Convert to LCOV (requires gocover-cobertura or similar)
# Note: This step is tool-dependent

# 3. Run Debtmap
debtmap analyze . --lcov coverage.lcov --languages go
```

## FAQ

### Why does my 100% covered function still show up?

Coverage dampens debt scores but doesn't eliminate debt. A function with cyclomatic complexity 25 and 100% coverage still represents technical debt—it's just lower priority than untested complex code.

**Use filters to focus on high-priority items**:
```bash
debtmap analyze . --lcov coverage.info --top 10
```

### What's the difference between direct and transitive coverage?

- **Direct coverage**: Lines executed directly by tests
- **Transitive coverage**: Coverage considering call graph (functions called by well-tested code)

Transitive coverage reduces urgency for functions only reachable through well-tested paths.

### Should I test everything to 100% coverage?

**No.** Use Debtmap's risk scores to prioritize:
1. Test high-complexity, low-coverage functions first
2. Entry points are better tested with integration tests
3. Simple utility functions (complexity < 5) may not need dedicated unit tests

Debtmap helps you achieve **optimal coverage**, not maximal coverage.

### How do I debug coverage correlation issues?

Use verbose logging:
```bash
debtmap analyze . --lcov coverage.info -vv
```

This shows:
- Coverage file parsing details
- Function-to-coverage correlation attempts
- Path matching diagnostics

### Can I use coverage with validate command?

Yes! The `validate` command supports `--lcov` for risk-based quality gates:
```bash
debtmap validate . --lcov coverage.info --max-debt-density 50
```

See [CLI Reference](cli-reference.md#validate-command) for details.

## Further Reading

- [Scoring Strategies](scoring-strategies.md) - Deep dive into how coverage affects unified scoring
- [Tiered Prioritization](tiered-prioritization.md) - How coverage fits into tiered priority levels
- [CLI Reference](cli-reference.md) - Complete coverage option documentation
- [Configuration](configuration.md) - Customizing coverage scoring weights
- [Troubleshooting](troubleshooting.md) - More debugging tips for coverage issues
