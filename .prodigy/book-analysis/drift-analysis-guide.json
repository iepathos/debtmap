{
  "chapter_id": "analysis-guide",
  "chapter_title": "Analysis Guide",
  "chapter_file": "book/src/analysis-guide.md",
  "drift_detected": true,
  "severity": "low",
  "quality_assessment": "Excellent - This chapter is comprehensive, accurate, and well-structured. It thoroughly covers all analyzer types (Rust, Python, JavaScript, TypeScript) and all metrics (cyclomatic, cognitive, entropy, nesting, length) with clear explanations, formulas, and examples. The unified scoring system (0-10 scale) is well-documented as the primary prioritization mechanism. Only minor documentation gaps detected that don't impact user understanding.",
  "issues": [
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Entropy-Based Complexity Analysis (Output fields)",
      "line_number": 155,
      "description": "Chapter mentions EntropyScore output fields (unique_variables, max_nesting, dampening_applied) but these fields are not documented in features.json complexity_metrics section",
      "current_content": "**Output fields in EntropyScore:**\n- `unique_variables`: Count of distinct variables in the function (measures variable diversity)\n- `max_nesting`: Maximum nesting depth detected (contributes to dampening calculation)\n- `dampening_applied`: Actual dampening factor applied to the complexity score",
      "should_be": "Verify these fields exist in the actual EntropyScore struct and add to features.json if missing, or remove from chapter if they don't exist",
      "fix_suggestion": "Cross-reference with src/complexity/entropy.rs or equivalent to verify EntropyScore struct fields. If fields exist, add to features.json. If not, update chapter to reflect actual output fields.",
      "source_reference": "features.json:complexity_metrics (fields not documented)"
    },
    {
      "type": "incorrect_information",
      "severity": "low",
      "section": "Debt Patterns - Debt Type Enum",
      "line_number": 298,
      "description": "Chapter states 'Debtmap detects 24 types of technical debt' but the enumeration that follows lists 25 distinct types (7 Testing + 7 Architecture + 8 Performance + 3 CodeQuality = 25)",
      "current_content": "Debtmap detects 24 types of technical debt, organized into 4 strategic categories.",
      "should_be": "Debtmap detects 25 types of technical debt, organized into 4 strategic categories.",
      "fix_suggestion": "Update the count from 24 to 25, or verify against actual DebtType enum in the codebase (src/debt/types.rs or equivalent) and adjust the list/count accordingly",
      "source_reference": "book/src/analysis-guide.md:300-336 (enumeration of all debt types)"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "JSON Structure - Function Metrics",
      "line_number": 1040,
      "description": "The est_branches field is documented in features.json as an 'estimated metric' (formula: max(nesting_depth, 1) × cyclomatic_complexity ÷ 3) but is not shown in the chapter's JSON structure example",
      "current_content": "JSON structure example showing function metrics without est_branches field",
      "should_be": "Include est_branches field in the JSON structure example with explanation that it's a formula-based estimate for test cases needed",
      "fix_suggestion": "Add est_branches to the JSON structure example around line 1051:\n\"cyclomatic\": 15,\n\"cognitive\": 22,\n\"est_branches\": 20,  // Estimated test cases needed (formula-based)\n\"nesting\": 4,\n\nAnd add to 'Reading Function Metrics' section:\n- `est_branches`: Estimated execution paths (formula: max(nesting_depth, 1) × cyclomatic ÷ 3) - approximates test cases needed for branch coverage",
      "source_reference": "features.json:complexity_metrics.estimated_metrics.est_branches"
    },
    {
      "type": "incomplete_explanation",
      "severity": "low",
      "section": "Risk Distribution - minimal_count field",
      "line_number": 965,
      "description": "Example JSON shows minimal_count field but this isn't clearly defined as a standard field in features.json risk_categories. The unified scoring section explains this but the connection could be clearer.",
      "current_content": "\"minimal_count\": 234,",
      "should_be": "Either clarify that minimal_count is specific to unified scoring (functions scoring 0-2.9) or use the standard risk category names from features.json",
      "fix_suggestion": "Add a note after the risk_distribution example around line 976:\n\n**Note on minimal_count**: In unified scoring (0-10 scale), `minimal_count` represents functions scoring 0-2.9, which includes:\n- Simple utility functions\n- Helper functions with low complexity\n- Well-tested complex code that scores low due to coverage dampening\n\nThis is not a separate category but an outcome of the unified scoring system. Complex business logic with 95% test coverage appropriately receives a minimal score, reflecting that good testing mitigates complexity risk.",
      "source_reference": "features.json:risk_assessment.risk_categories (does not list minimal_count)"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Reading Function Metrics - FunctionVisibility enum",
      "line_number": 1135,
      "description": "Chapter documents visibility field values ('Private', 'Crate', 'Public') from FunctionVisibility enum, but this enum is not explicitly documented in features.json",
      "current_content": "- `visibility`: Function visibility (`\"Private\"`, `\"Crate\"`, or `\"Public\"` from FunctionVisibility enum)",
      "should_be": "Add FunctionVisibility enum to features.json or note in chapter that these values are Rust-specific conventions",
      "fix_suggestion": "Either add to features.json under rust language section:\n\"visibility_enum\": {\n  \"Private\": \"Function visible only within module (no pub modifier)\",\n  \"Crate\": \"Function visible within crate (pub(crate))\",\n  \"Public\": \"Function is public API (pub)\"\n}\n\nOr add note in chapter: '// Rust-specific visibility based on pub/pub(crate) modifiers. Other languages may have different visibility models.'",
      "source_reference": "features.json (FunctionVisibility enum not documented)"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Debt Patterns - Language-Specific Patterns",
      "line_number": 359,
      "description": "Chapter lists all debt types but doesn't clarify which patterns only apply to specific languages with relevant features",
      "current_content": "Lists all debt types under categories but doesn't note language-specific applicability",
      "should_add": "Note which debt patterns are language-specific: BlockingIO/AsyncMisuse (async languages), AllocationInefficiency/ResourceLeak (manual memory management languages)",
      "fix_suggestion": "Add subsection after line 366 'Language-Specific Debt Patterns':\n\n**Language-Specific Debt Patterns:**\n\nSome debt patterns only apply to languages with specific features:\n- **BlockingIO, AsyncMisuse**: Async-capable languages (Rust, JavaScript, TypeScript)\n- **AllocationInefficiency, ResourceLeak**: Languages with manual memory management (Rust)\n- **Error handling patterns**: Vary by language error model (Result in Rust, exceptions in Python/JS)\n\nDebtmap automatically applies only the relevant debt patterns for each language during analysis.",
      "source_reference": "features.json:debt_detection and src/analyzers/ language-specific implementations"
    },
    {
      "type": "incomplete_explanation",
      "severity": "low",
      "section": "Unified Scoring System - Dependency Factor",
      "line_number": 714,
      "description": "Chapter explains dependency factor calculation but doesn't provide specific numeric thresholds for what constitutes 'high', 'moderate', or 'low' upstream caller counts",
      "current_content": "**Dependency Factor** (0-10 scale):\nBased on call graph analysis:\n- High upstream caller count (many functions depend on this): 8-10\n- On critical paths from entry points: 7-9\n- Moderate dependencies: 4-6\n- Isolated utilities: 1-3",
      "should_be": "Provide concrete numeric thresholds: 'High impact = 5+ callers (score 8-10), Moderate = 2-4 callers (score 4-6), Low = 0-1 callers (score 1-3)'",
      "fix_suggestion": "Update the Dependency Factor description around line 714 to include specific thresholds:\n\n**Dependency Factor** (0-10 scale):\nBased on call graph analysis with specific thresholds:\n- **High impact** (score 8-10): 5+ upstream callers, or on critical path from entry point (adds 2-3 points)\n- **Moderate impact** (score 4-6): 2-4 upstream callers\n- **Low impact** (score 1-3): 0-1 upstream callers\n- **Critical path bonus**: Being on a critical path from an entry point adds 2-3 points to the base dependency score",
      "source_reference": "src/risk/scoring.rs or equivalent unified scoring implementation"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "JSON Output Format Variants",
      "line_number": 1102,
      "description": "Chapter mentions unified format (spec 108) but notes it's not currently exposed as a CLI option. This should be clarified more prominently.",
      "current_content": "**Unified Format (spec 108 - future enhancement):**\n- Uses consistent structure with `\"type\"` field discriminator\n- Simpler parsing for new integrations\n- Example structure shown\n\n**Note:** The unified format is currently an internal representation. If you need this format exposed as a CLI option, please open a feature request on GitHub.",
      "should_be": "Make it clearer whether this is available to users or purely internal",
      "fix_suggestion": "Update the note to be more prominent:\n\n**Note:** The unified format is currently an internal representation and is **not available** as a user-facing CLI option. The legacy format remains the stable default for all current integrations. If you need the unified format exposed as a CLI option (`--format json-unified`), please open a feature request on GitHub.",
      "source_reference": "features.json:output_formats.json.formats"
    },
    {
      "type": "incomplete_explanation",
      "severity": "low",
      "section": "Coverage Integration - Performance Characteristics",
      "line_number": 2391,
      "description": "Chapter provides detailed performance metrics (2.5x overhead) but doesn't explain when users should consider skipping coverage for faster iteration",
      "current_content": "**Analysis Overhead:**\n- Coverage integration overhead: ~2.5x baseline analysis time\n- Target overhead: ≤3x (maintained through optimizations)\n- Example timing: 53ms baseline → 130ms with coverage (2.45x overhead)",
      "should_add": "Practical guidance on when the 2.5x overhead is acceptable vs. when to omit coverage",
      "fix_suggestion": "Add a subsection after line 2399 'When to use coverage integration':\n\n**When to use coverage integration:**\n- **Skip coverage** (faster iteration): For rapid development iteration or quick local checks, omit `--lcov` to get baseline results 2.5x faster\n- **Include coverage** (comprehensive analysis): Use coverage integration for final validation, sprint planning, and CI/CD gates where comprehensive risk analysis is needed",
      "source_reference": "Coverage integration performance documentation and best practices"
    }
  ],
  "positive_aspects": [
    "Extremely comprehensive coverage of all analysis capabilities",
    "Excellent examples throughout - code samples, JSON output, and terminal output",
    "Clear distinction between unified scoring (0-10) and legacy scoring systems",
    "Strong explanation of entropy-based complexity and pattern detection with Shannon entropy formulas",
    "Helpful before/after refactoring comparisons",
    "Good integration of theory (formulas) with practice (CLI examples)",
    "Clear documentation of all debt types with when/why/action guidance",
    "Coverage integration performance characteristics well documented with specific timing metrics",
    "Advanced features (data flow, purity detection, call graph) thoroughly explained",
    "Strategic guidance for different prioritization approaches",
    "Excellent cross-referencing between sections",
    "Outstanding unified scoring system documentation with all three factors (complexity 40%, coverage 40%, dependency 20%) clearly explained",
    "Role-based prioritization well-documented with all six role types and their multipliers",
    "Coverage propagation explanation with concrete scenarios showing transitive coverage benefits",
    "DataFlowGraph integration with unified scoring's dependency factor is clearly explained",
    "Tiered prioritization section provides effort estimates and strategic guidance for each tier",
    "Categorized debt analysis with cross-category dependencies is comprehensive",
    "Debt density metric explanation includes CI/CD integration examples",
    "All four supported languages (Rust, Python, JavaScript, TypeScript) thoroughly documented with capabilities",
    "Semantic classification for Rust (entry points, business logic, data access, infrastructure, utilities, test code) well-explained",
    "Extensibility guidance helps contributors understand how to add new language support"
  ],
  "improvement_suggestions": [
    "Verify EntropyScore output fields against actual implementation and sync with features.json",
    "Correct the debt type count (24 vs 25) to match actual implementation",
    "Add est_branches field to JSON structure examples with explanation",
    "Clarify minimal_count field meaning in risk distribution examples",
    "Document FunctionVisibility enum values in features.json",
    "Add language-specific debt patterns subsection explaining which patterns apply to which languages",
    "Provide concrete numeric thresholds for dependency factor scoring (exact caller counts)",
    "Clarify unified JSON format availability status more prominently",
    "Add guidance on when to skip coverage integration for faster iteration",
    "Add a quick-start section at the beginning for users who want to jump in immediately",
    "Consider adding a flowchart showing the decision tree for choosing analysis strategies",
    "Include a troubleshooting section with common interpretation mistakes",
    "Add more examples of analyzing multi-language projects",
    "Consider adding a glossary of terms (entropy, cyclomatic, cognitive, etc.)",
    "Add references to academic papers or resources for users wanting deeper understanding",
    "Include example CI/CD pipeline configurations using different CI systems",
    "Add section on interpreting results for different team roles (developers vs managers)"
  ],
  "metadata": {
    "analyzed_at": "2025-10-30",
    "feature_inventory": ".prodigy/book-analysis/features.json",
    "topics_covered": [
      "Complexity metrics (cyclomatic, cognitive, entropy, nesting, length)",
      "Debt patterns (24-25 types across 4 categories: Testing, Architecture, Performance, CodeQuality)",
      "Unified scoring system (0-10 scale with three weighted factors: complexity 40%, coverage 40%, dependency 20%)",
      "Role-based prioritization (6 role types: Entry Points 1.5×, Business Logic 1.2×, Data Access 1.0×, Infrastructure 0.8×, Utilities 0.5×, Test Code 0.1×)",
      "Coverage propagation (transitive coverage through call graph)",
      "Legacy risk scoring (for compatibility with pre-0.2.x versions)",
      "Risk categories (Critical, High, Medium, Low, WellTested)",
      "Test effort assessment (Trivial, Simple, Moderate, Complex, VeryComplex)",
      "Interpreting results (output formats, prioritization strategies, tiered display)",
      "Analyzer types (Rust full support, Python/JavaScript/TypeScript partial support)",
      "Semantic classification (Rust-specific: entry points, business logic, data access, infrastructure, utilities, test code)",
      "Advanced features (purity detection, data flow graph, call graph, entropy caching, context-aware analysis, coverage integration)",
      "Performance characteristics (coverage index O(1) lookups ~0.5μs, 2.5x overhead with coverage, entropy caching)",
      "Tiered prioritization (Critical ≥90, High 70-89.9, Moderate 50-69.9, Low <50)",
      "Categorized debt analysis (CategorySummary, CrossCategoryDependency)",
      "Debt density metric (normalized per 1000 LOC)",
      "God object detection with complexity weighting",
      "Constructor detection (AST-based with fallback)",
      "Data transformation patterns (Map, Filter, Reduce, FlatMap)"
    ],
    "validation_focus": "Ensure all analyzer types and metrics are explained",
    "validation_result": "PASS - All analyzer types thoroughly documented: Rust (full support with syn parser, call graph, trait resolution, macro expansion, semantic classification), Python (partial support with rustpython-parser), JavaScript (partial support with tree-sitter), TypeScript (partial support with tree-sitter). All complexity metrics explained with formulas and thresholds: cyclomatic (decision points), cognitive (understanding difficulty with nesting weight), entropy (pattern detection with Shannon entropy), nesting depth (indentation levels), function length (LOC). Unified scoring system (0-10 scale) comprehensively covered as primary prioritization mechanism.",
    "chapter_length": "2,621 lines",
    "issues_found": 9,
    "high_severity_count": 0,
    "medium_severity_count": 0,
    "low_severity_count": 9
  }
}
