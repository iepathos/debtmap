{
  "chapter_id": "god-object-detection",
  "chapter_title": "God Object Detection",
  "chapter_file": "book/src/god-object-detection.md",
  "drift_detected": true,
  "severity": "critical",
  "quality_assessment": "Chapter does not exist yet (auto-generated). Must be created with comprehensive coverage of god object detection algorithm, scoring, configuration, and CLI options.",
  "issues": [
    {
      "type": "missing_content",
      "severity": "high",
      "section": "Detection Criteria",
      "description": "Chapter needs to document all detection criteria used to identify god objects",
      "should_add": "Document method count, field count, responsibility count (max_traits), lines of code, and complexity sum as detection criteria. Include language-specific thresholds from GodObjectThresholds.",
      "fix_suggestion": "Create section explaining how each criterion is measured: methods (includes both impl methods and standalone functions), fields (struct/class fields), responsibilities (inferred from method name prefixes), LOC, and total complexity. Reference src/organization/god_object_detector.rs:46-97 for file-level aggregation logic.",
      "source_reference": "src/organization/god_object_analysis.rs:47-98, src/organization/god_object_detector.rs:46-194"
    },
    {
      "type": "missing_content",
      "severity": "high",
      "section": "Scoring Algorithm",
      "description": "Chapter must explain both simple and complexity-weighted scoring algorithms",
      "should_add": "Document calculate_god_object_score (simple) and calculate_god_object_score_weighted (complexity-weighted) formulas. Explain method_factor, field_factor, responsibility_factor, size_factor calculations with min(x, 3.0) capping. Document minimum score enforcement of 100 for any violation.",
      "fix_suggestion": "Add section showing scoring formula: base_score = method_factor × field_factor × responsibility_factor × size_factor, then final_score = max(base_score × 50 × violation_count, 100) for god objects. Explain complexity weighting uses aggregate_weighted_complexity instead of raw counts. Include purity-weighted scoring variant that reduces weight for pure functions (0.3x multiplier).",
      "source_reference": "src/organization/god_object_analysis.rs:100-227, src/organization/complexity_weighting.rs"
    },
    {
      "type": "missing_content",
      "severity": "high",
      "section": "Thresholds and Configuration",
      "description": "Chapter needs comprehensive documentation of all configuration options",
      "should_add": "Document .debtmap.toml [god_object_detection] section with enabled, rust.max_methods, rust.max_fields, rust.max_traits, rust.max_lines, rust.max_complexity, and equivalents for python and javascript. Document CLI flags: --no-god-object, --aggregate-only, --no-aggregation, --aggregation-method, --min-problematic.",
      "fix_suggestion": "Create configuration section with TOML examples showing default thresholds (Rust: 20/15/5/1000/200, Python: 15/10/3/500/150, JS/TS: 15/20/3/500/150). Explain how to customize per language. Document that enabled defaults to true.",
      "source_reference": "src/config.rs:500-582, features.json:65-71, features.json:507-512"
    },
    {
      "type": "missing_content",
      "severity": "medium",
      "section": "File-Level Aggregation",
      "description": "Chapter should explain how standalone functions and struct methods are combined",
      "should_add": "Document that god object detection aggregates both struct/class methods AND standalone functions in the same file. Explain the logic: finds largest type by (method_count + field_count × 2), then combines with standalone_functions for total analysis.",
      "fix_suggestion": "Add explanation that files with many standalone functions (like rust_call_graph.rs with 270 functions) are detected as god objects. Show how total_methods = type_info.method_count + standalone_count. This is critical for understanding why pure functional modules get flagged.",
      "source_reference": "src/organization/god_object_detector.rs:66-97"
    },
    {
      "type": "missing_content",
      "severity": "medium",
      "section": "Confidence Levels",
      "description": "Chapter must document the four confidence levels and their criteria",
      "should_add": "Document Definite (5 violations), Probable (3-4 violations), Possible (1-2 violations), NotGodObject (0 violations). Explain that violations are counted across method count, field count, responsibilities, lines of code, and complexity thresholds.",
      "fix_suggestion": "Create subsection showing confidence determination logic from determine_confidence function. Clarify that god_object_score >= 70.0 is the final determinant, not just confidence level.",
      "source_reference": "src/organization/god_object_analysis.rs:229-270, src/organization/god_object_detector.rs:152-163"
    },
    {
      "type": "missing_content",
      "severity": "medium",
      "section": "Responsibility Detection",
      "description": "Chapter should document how responsibilities are inferred from method names",
      "should_add": "Document the full list of common prefixes and their responsibility classifications: get/set→Data Access, calculate/compute→Computation, validate/check/verify→Validation, save/load/store/retrieve/fetch→Persistence, create/build/new/make/init→Construction, send/receive/handle/manage→Communication, update/modify/change/edit→Modification, delete/remove/clear/reset→Deletion, is/has/can/should/will→State Query, process/transform→Processing.",
      "fix_suggestion": "Create table or list showing all 28 common prefixes and their classifications. Explain default fallback: '{prefix} Operations' with capitalized first letter. Note that responsibility_count affects both scoring and refactoring recommendations.",
      "source_reference": "src/organization/god_object_detector.rs:378-454"
    },
    {
      "type": "missing_content",
      "severity": "medium",
      "section": "Refactoring Recommendations",
      "description": "Chapter should explain how module split suggestions are generated",
      "should_add": "Document that when is_god_object=true, debtmap generates recommended_splits using recommend_module_splits function. Splits are based on responsibility groups. Each ModuleSplit includes suggested_name, methods_to_move, responsibility, and estimated_lines.",
      "fix_suggestion": "Add section showing example output with suggested module names like 'DataAccessManager', 'ValidationManager', etc. Explain how methods are grouped by their inferred responsibilities for cohesive splits.",
      "source_reference": "src/organization/god_object_detector.rs:165-177, src/organization/god_object_analysis.rs:40-45"
    },
    {
      "type": "missing_content",
      "severity": "medium",
      "section": "Purity-Weighted Scoring",
      "description": "Chapter should document advanced purity-weighted scoring that reduces impact of pure functions",
      "should_add": "Document that god object detection analyzes function purity (Pure, ProbablyPure, Impure) and applies weight multipliers: Pure=0.3x, ProbablyPure=0.5x, Impure=1.0x. Total weight combines complexity_weight × purity_multiplier. This prevents pure functional modules from being unfairly penalized.",
      "fix_suggestion": "Create advanced section explaining PurityDistribution with pure_count, probably_pure_count, impure_count and their weighted contributions. Explain this is only available for Rust (requires syn::ItemFn analysis).",
      "source_reference": "src/organization/god_object_detector.rs:117-121, 196-258, src/organization/purity_analyzer.rs"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Examples and Case Studies",
      "description": "Chapter needs practical examples showing real-world god object detections",
      "should_add": "Provide examples: (1) Large Rust module with 270 standalone functions like rust_call_graph.rs, (2) Python class with 25 methods and 12 fields, (3) File that combines struct with 15 methods plus 10 standalone functions = 25 total.",
      "fix_suggestion": "Create examples section with before/after scenarios, showing actual debtmap output format with '⚠️ God Object: X methods, Y fields, Z responsibilities' indicator. Include expected scores and confidence levels for each example.",
      "source_reference": "docs/GOD_OBJECT_DETECTION.md:84-102 (existing examples can be used)"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Integration with File-Level Scoring",
      "description": "Chapter should explain how god object detection affects overall file scores",
      "should_add": "Document that god_object_multiplier = 2.0 + god_object_score (normalized to 0-1 range) is applied to file-level technical debt scores. God objects receive higher priority in overall analysis.",
      "fix_suggestion": "Add section linking to file-level scoring chapter, explaining cascading impact where functions within god objects may inherit elevated priority due to architectural concerns.",
      "source_reference": "features.json:570, file_level_scoring section"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "CLI Options",
      "description": "Chapter should document all CLI flags for god object detection",
      "should_add": "Document --no-god-object (disable detection), --aggregate-only (show only file-level scores, hide individual functions), --no-aggregation (disable file-level aggregation), --aggregation-method (sum, weighted_sum, logarithmic_sum, max_plus_average), --min-problematic (minimum number of problematic functions for file aggregation).",
      "fix_suggestion": "Create CLI reference subsection with usage examples: 'debtmap analyze . --no-god-object', 'debtmap analyze . --aggregate-only', etc. Explain use cases for each flag.",
      "source_reference": "features.json:65-71, src/cli.rs (god_object-related flags)"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Metrics Tracking",
      "description": "Chapter could document GodObjectMetrics for tracking god objects over time",
      "should_add": "Optionally document the metrics tracking system with snapshots, trends, new_god_objects detection, and resolved_god_objects tracking. This is an advanced feature for monitoring god object evolution.",
      "fix_suggestion": "Consider adding optional advanced section on tracking god object metrics over time using GodObjectMetrics with FileTrend analysis (Improving/Stable/Worsening based on score changes >10 points).",
      "source_reference": "src/organization/god_object_metrics.rs:1-228"
    }
  ],
  "positive_aspects": [
    "Existing GOD_OBJECT_DETECTION.md provides good starting foundation",
    "Clear feature definition in features.json with all capabilities listed",
    "Comprehensive implementation with multiple scoring variants (simple, weighted, purity-weighted)",
    "Well-tested with god_object_detection_test.rs and god_object_metrics_test.rs",
    "Language-specific thresholds properly configured for Rust, Python, and JavaScript/TypeScript"
  ],
  "improvement_suggestions": [
    "Create chapter showing progression: detection criteria → scoring algorithm → configuration → CLI usage → refactoring recommendations → examples",
    "Include visual diagrams showing how method_factor, field_factor, responsibility_factor, and size_factor combine into final score",
    "Add comparison table showing default thresholds across all three languages (Rust vs Python vs JS/TS)",
    "Provide decision tree: when to use --aggregate-only vs --no-aggregation vs default behavior",
    "Include troubleshooting section for common issues like 'why is my functional module flagged as god object?' (answer: because it has many standalone functions, consider purity-weighted scoring)",
    "Link to related chapters: File-Level Scoring, Configuration, CLI Reference, Refactoring Strategies",
    "Add code examples showing TOML configuration for customizing thresholds per project needs",
    "Explain the tradeoff: strict thresholds catch problems early but may flag legitimate large modules; lenient thresholds reduce noise but miss real god objects"
  ],
  "metadata": {
    "analyzed_at": "2025-01-20",
    "feature_inventory": ".prodigy/book-analysis/features.json",
    "topics_covered": [
      "Detection criteria (method count, field count, responsibilities)",
      "God object scoring algorithm (simple and complexity-weighted)",
      "Thresholds and configuration (.debtmap.toml and CLI)",
      "File-level aggregation (standalone functions + struct methods)",
      "Refactoring recommendations (responsibility-based splits)",
      "Purity-weighted scoring (advanced)"
    ],
    "validation_focus": "Check that god object detection algorithm, scoring, and configuration options are documented",
    "implementation_files": [
      "src/organization/god_object_detector.rs",
      "src/organization/god_object_analysis.rs",
      "src/organization/god_object_metrics.rs",
      "src/organization/purity_analyzer.rs",
      "src/organization/complexity_weighting.rs",
      "src/config.rs (GodObjectConfig, GodObjectThresholds)",
      "src/cli.rs (god_object CLI flags)"
    ],
    "test_files": [
      "tests/god_object_detection_test.rs",
      "tests/god_object_metrics_test.rs"
    ],
    "existing_docs": [
      "docs/GOD_OBJECT_DETECTION.md"
    ]
  }
}
