{
  "chapter_id": "examples",
  "chapter_title": "Examples",
  "chapter_file": "book/src/examples.md",
  "drift_detected": true,
  "severity": "medium",
  "quality_assessment": "Chapter is comprehensive and well-structured with good practical examples. Previous CLI syntax errors have been corrected. Main gaps are missing coverage of some advanced CLI options and features available in the codebase (pattern detection, dead code analysis, cache location strategies, and some debugging options).",
  "issues": [
    {
      "type": "missing_content",
      "severity": "medium",
      "section": "Output Formats - Understanding Output Formats (lines 665-689)",
      "description": "The unified vs legacy JSON format distinction is mentioned but not adequately explained with concrete examples showing structural differences",
      "should_add": "Add concrete JSON examples showing the difference between legacy format (with File/Function wrappers) and unified format (with consistent 'type' field)",
      "fix_suggestion": "Add a subsection with side-by-side JSON examples:\n\n**Legacy format (default):**\n```json\n{\n  \"items\": [\n    {\"File\": {\"path\": \"src/main.rs\", \"score\": 45.2}},\n    {\"Function\": {\"name\": \"process\", \"complexity\": 12}}\n  ]\n}\n```\n\n**Unified format:**\n```json\n{\n  \"items\": [\n    {\"type\": \"file\", \"path\": \"src/main.rs\", \"score\": 45.2},\n    {\"type\": \"function\", \"name\": \"process\", \"complexity\": 12}\n  ]\n}\n```\n\nExplain: Unified format has consistent structure with 'type' discriminator field, easier to parse programmatically, better for new integrations. Legacy format uses wrapper objects for backward compatibility.",
      "source_reference": "features.json:512-514 (json.formats.legacy and json.formats.unified)"
    },
    {
      "type": "missing_content",
      "severity": "medium",
      "section": "Advanced Usage - Pattern Detection",
      "description": "Chapter doesn't mention pattern detection features available via CLI that can detect design patterns like observer, singleton, factory, strategy, callback, and template_method",
      "should_add": "Document --no-pattern-detection, --patterns, --pattern-threshold, --show-pattern-warnings options",
      "fix_suggestion": "Add new subsection 'Design Pattern Detection' under Advanced Usage:\n\n```bash\n# Detect specific design patterns\ndebtmap analyze . --patterns observer,singleton,factory\n\n# Adjust pattern confidence threshold (0.0-1.0, default: 0.7)\ndebtmap analyze . --pattern-threshold 0.8\n\n# Show uncertain pattern matches with warnings\ndebtmap analyze . --show-pattern-warnings\n\n# Disable pattern detection entirely\ndebtmap analyze . --no-pattern-detection\n```\n\n**Available patterns:**\n- `observer` - Event listener registrations, callback patterns\n- `singleton` - Static instance management\n- `factory` - Object creation methods\n- `strategy` - Algorithm selection via traits/interfaces\n- `callback` - Function passing and invocation\n- `template_method` - Abstract methods with concrete implementations\n\n**Use cases:**\n- Identify architectural patterns in unfamiliar codebases\n- Detect potential overuse of certain patterns (e.g., too many singletons)\n- Understand code organization and design decisions",
      "source_reference": "features.json:66-71 (pattern_detection options), features.json:589-597 (design_patterns_detected)"
    },
    {
      "type": "missing_content",
      "severity": "medium",
      "section": "Advanced Usage - Dead Code and Public API Analysis",
      "description": "No mention of public API detection options for library analysis, which help prevent false positives when analyzing libraries vs CLI tools",
      "should_add": "Document --no-public-api-detection and --public-api-threshold options with context about when to use them",
      "fix_suggestion": "Add new subsection 'Dead Code and Public API Analysis' under Advanced Usage:\n\n```bash\n# Analyze with public API awareness (default for libraries)\ndebtmap analyze . --context\n\n# Disable public API heuristics (useful for CLI tools)\ndebtmap analyze . --no-public-api-detection\n\n# Adjust public API confidence threshold (default: 0.7)\ndebtmap analyze . --public-api-threshold 0.8\n```\n\n**When to use:**\n- **Libraries**: Keep default public API detection to avoid flagging exported functions as unused\n- **CLI tools**: Use `--no-public-api-detection` since there's no public API\n- **Mixed projects**: Adjust threshold based on false positive rate\n\n**What it detects:**\n- Functions exported in `lib.rs` or `api.rs`\n- Public trait implementations\n- Functions matching API naming patterns\n- Prevents false positives for \"unused\" library functions",
      "source_reference": "features.json:72-75 (dead_code_analysis options)"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Advanced Usage - Cache Management (lines 717-728)",
      "description": "Cache management section doesn't mention --cache-location strategy option for controlling where cache is stored",
      "current_content": "Shows --cache-stats, --clear-cache, --force-cache-rebuild",
      "should_add": "Document --cache-location option with strategies (local, shared, custom path)",
      "fix_suggestion": "Add to Cache Management section:\n\n```bash\n# Use per-project cache (default)\ndebtmap analyze . --cache-location local\n\n# Use shared system-wide cache for faster multi-project analysis\ndebtmap analyze . --cache-location shared\n\n# Use custom cache directory\ndebtmap analyze . --cache-location /custom/path/to/cache\n```\n\n**Cache strategies:**\n- **local**: Per-project cache in `.debtmap-cache/` (default)\n- **shared**: Shared cache directory for all projects (faster when analyzing multiple projects)\n- **custom path**: Specify exact cache location\n\n**Benefits:**\n- Shared cache reduces analysis time when working on multiple projects\n- Custom path useful for CI systems with specific cache directories\n- Local cache isolates project-specific analysis results",
      "source_reference": "features.json:49 (cache_location), features.json:579-581 (caching.strategies)"
    },
    {
      "type": "incomplete_explanation",
      "severity": "low",
      "section": "Advanced Usage - Context-Aware Analysis (lines 692-706)",
      "description": "Context providers are mentioned but not fully explained with detailed use cases and what each provider does",
      "current_content": "Lists critical_path, dependency, git_history providers and shows how to enable/disable them",
      "should_add": "Expand explanation of what each provider does and when to use it",
      "fix_suggestion": "Expand context provider documentation:\n\n```bash\n# Enable all context providers for comprehensive analysis\ndebtmap analyze . \\\n  --context \\\n  --context-providers critical_path,dependency,git_history\n```\n\n**Context Providers:**\n\n**critical_path** - Identifies functions on critical execution paths\n- Analyzes call graph to find frequently-called functions\n- Prioritizes functions that affect many code paths\n- Use for: Understanding impact of potential failures\n\n**dependency** - Analyzes dependency impact and cascade effects\n- Tracks caller/callee relationships\n- Calculates cascade impact of changes\n- Use for: Understanding change propagation and refactoring risk\n\n**git_history** - Tracks change frequency and churn\n- Analyzes git blame and commit history\n- Identifies frequently-changed functions\n- Use for: Finding volatile code that needs stabilization\n\n**Example workflows:**\n```bash\n# Find volatile high-complexity code\ndebtmap analyze . --context --context-providers git_history\n\n# Understand refactoring impact\ndebtmap analyze . --context --context-providers dependency\n\n# Disable slow provider for faster analysis\ndebtmap analyze . --context --disable-context git_history\n```",
      "source_reference": "features.json:471-475 (context_providers with detailed descriptions)"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Advanced Usage - Call Graph Debugging",
      "description": "Chapter mentions --debug-call-graph briefly in common patterns section but doesn't cover all available debugging options comprehensively",
      "current_content": "Common patterns section shows: debtmap analyze . --debug-call-graph --trace-function my_function",
      "should_add": "Add comprehensive call graph debugging section with all options and use cases",
      "fix_suggestion": "Add new subsection 'Call Graph Debugging' under Advanced Usage:\n\n```bash\n# Enable call graph debugging output\ndebtmap analyze . --debug-call-graph\n\n# Trace specific function resolution\ndebtmap analyze . --trace-function my_function --trace-function another_fn\n\n# Validate call graph structure (detect orphans and cycles)\ndebtmap analyze . --validate-call-graph\n\n# Show detailed caller/callee relationships\ndebtmap analyze . --show-dependencies\n```\n\n**Use cases:**\n\n**Troubleshooting resolution failures:**\n```bash\n# When a function isn't being analyzed correctly\ndebtmap analyze . --debug-call-graph --trace-function problematic_function\n```\n\n**Understanding function relationships:**\n```bash\n# See who calls what\ndebtmap analyze . --show-dependencies --top 10\n```\n\n**Validating call graph integrity:**\n```bash\n# Detect cycles and orphaned nodes\ndebtmap analyze . --validate-call-graph\n```\n\nOutput includes:\n- Resolution statistics (success/failure rates)\n- DFS cycle detection results\n- Orphan node detection\n- Cross-module resolution details",
      "source_reference": "features.json:51-57 (advanced_features call graph options), features.json:176-180 (call_graph capabilities)"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Output Formats or Advanced Usage",
      "description": "Missing --detail-level option for markdown output that controls how much detail is included",
      "should_add": "Document detail levels available for markdown output (summary, standard, comprehensive, debug)",
      "fix_suggestion": "Add to Output Formats section under Markdown Report:\n\n```bash\n# Summary level for executives (minimal detail)\ndebtmap analyze . --format markdown --detail-level summary --output SUMMARY.md\n\n# Standard level for team review (default)\ndebtmap analyze . --format markdown --detail-level standard --output DEBT.md\n\n# Comprehensive level for deep analysis\ndebtmap analyze . --format markdown --detail-level comprehensive --output DETAILED.md\n\n# Debug level for troubleshooting\ndebtmap analyze . --format markdown --detail-level debug --output DEBUG.md\n```\n\n**Detail levels:**\n- **summary**: Executive summary with key metrics and top issues only\n- **standard**: Balanced detail suitable for team reviews (default)\n- **comprehensive**: Full details including all debt items and analysis\n- **debug**: Maximum detail including AST information and parser internals\n\n**Use cases:**\n- Summary: Management reports, PR comments\n- Standard: Regular team reviews\n- Comprehensive: Deep dives, refactoring planning\n- Debug: Troubleshooting debtmap behavior",
      "source_reference": "features.json:28 (detail_level option), features.json:535 (markdown.detail_levels)"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Advanced Usage - Metrics Understanding",
      "description": "Missing --explain-metrics flag that helps users understand metric definitions and formulas, especially the difference between measured and estimated metrics",
      "should_add": "Document --explain-metrics for understanding how metrics are calculated",
      "fix_suggestion": "Add new subsection 'Understanding Metrics' under Advanced Usage or create standalone section:\n\n```bash\n# Show metric definitions and formulas\ndebtmap analyze . --explain-metrics\n```\n\n**What it explains:**\n\n**Measured metrics** (counted from AST):\n- `cyclomatic_complexity` - Decision points (if, match, while, for, etc.)\n- `cognitive_complexity` - Weighted readability measure\n- `nesting_depth` - Maximum nested control structure levels\n- `loc` - Lines of code in function\n- `parameter_count` - Number of function parameters\n\n**Estimated metrics** (formula-based approximations):\n- `est_branches` - Estimated execution paths\n  - Formula: `max(nesting_depth, 1) × cyclomatic_complexity ÷ 3`\n  - Purpose: Estimate test cases needed for branch coverage\n  - Note: This is an ESTIMATE, not a count from the AST\n\n**Scoring formulas:**\n- Complexity factor calculation\n- Coverage factor weight\n- Dependency factor impact\n- Role multiplier application\n- Final score aggregation\n\n**Use --explain-metrics when:**\n- First learning debtmap\n- Questioning why something is flagged\n- Understanding score differences\n- Teaching team members about technical debt metrics",
      "source_reference": "features.json:57 (explain_metrics), features.json:152-173 (complexity_metrics with measured vs estimated)"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Advanced Usage - Functional Analysis",
      "description": "No mention of --ast-functional-analysis flag for detecting functional programming patterns",
      "should_add": "Document AST-based functional composition analysis",
      "fix_suggestion": "Add to Advanced Usage:\n\n```bash\n# Enable AST-based functional composition analysis\ndebtmap analyze . --ast-functional-analysis\n\n# Combine with verbose mode to see purity analysis\ndebtmap analyze . --ast-functional-analysis -v\n```\n\n**What it detects:**\n- Pure functions (no side effects, immutable)\n- Impure functions (I/O, mutations, side effects)\n- Function composition patterns\n- Immutability patterns\n\n**Benefits:**\n- Distinguishes functional patterns from god objects (see purity weighting in lines 118-171)\n- Identifies opportunities for better testability\n- Highlights side effect boundaries\n- Supports functional programming code reviews\n\n**Example output with -v:**\n```\nPURITY DISTRIBUTION:\n  Pure: 70 functions (65%) → complexity weight: 6.3\n  Impure: 37 functions (35%) → complexity weight: 14.0\n  Total weighted complexity: 20.3\n```",
      "source_reference": "features.json:56 (ast_functional_analysis), features.json:185-189 (functional_composition profiles)"
    },
    {
      "type": "incomplete_explanation",
      "severity": "low",
      "section": "Configuration Examples - God Object Detection Tuning (lines 846-872)",
      "description": "Configuration example shows language-specific thresholds but doesn't mention how to configure purity weighting despite detailed usage explanation earlier in the chapter",
      "current_content": "Shows max_methods, max_fields, max_lines, max_complexity thresholds per language",
      "should_add": "Add purity weighting configuration options to god object tuning example",
      "fix_suggestion": "Add to the [god_object] configuration section:\n\n```toml\n[god_object]\nenabled = true\n\n# Purity-based scoring reduces false positives for functional code\n# Pure functions (no side effects) get lower weight in god object scoring\npurity_weight_pure = 0.3    # Pure function complexity weight (default: 0.3)\npurity_weight_impure = 1.0  # Impure function complexity weight (default: 1.0)\n\n# Rust-specific thresholds\n[god_object.rust]\nmax_methods = 25\nmax_fields = 15\nmax_traits = 5\nmax_lines = 400\nmax_complexity = 50\n\n# ... rest of language configs\n```\n\n**Why purity weighting matters:**\nSee lines 118-171 for detailed explanation. In short:\n- Modules with many pure helper functions avoid false god object flags\n- Focus shifts to modules with excessive stateful/impure code\n- Functional programming patterns are properly recognized\n\n**Example:**\n- Module with 100 pure functions → Normal (functional design) ✅\n- Module with 100 impure functions → God object detected ✅",
      "source_reference": "features.json:185-189 (functional_composition.scoring with purity), chapter lines 118-171 (existing purity explanation)"
    },
    {
      "type": "incomplete_explanation",
      "severity": "low",
      "section": "Analyzing Rust Projects - Basic Rust Analysis (lines 38-47)",
      "description": "Basic examples show 'debtmap analyze .' but don't clarify that the path argument defaults to current directory",
      "current_content": "Shows 'debtmap analyze .', 'debtmap analyze ./src'",
      "should_add": "Clarify that '.' is the default and can be omitted",
      "fix_suggestion": "Add note at the beginning:\n\n```bash\n# Analyze current directory (path defaults to '.')\ndebtmap analyze\n\n# Same as above (explicit current directory)\ndebtmap analyze .\n\n# Analyze specific directory\ndebtmap analyze ./src\n```",
      "source_reference": "features.json:12 (analyze command path parameter with description)"
    }
  ],
  "positive_aspects": [
    "Excellent structure with clear table of contents and quick navigation",
    "Comprehensive language-specific examples (Rust, Python, JavaScript/TypeScript)",
    "Outstanding CI/CD integration examples with complete real-world workflows (GitHub Actions, GitLab CI, CircleCI)",
    "Strong coverage integration examples with cargo-tarpaulin, pytest, and Jest",
    "Good progression from basic to advanced usage",
    "Outstanding god object purity weighting explanation (lines 118-171) with clear examples and comparison tables",
    "Thorough compare command section with practical workflows and interpretation guidance",
    "Comprehensive configuration examples well-organized by use case",
    "Good use of code examples that are copy-paste ready",
    "Helpful tips and best practices section",
    "Proper cross-references to other chapters (CLI Reference, Analysis Guide, Configuration)",
    "Output format examples include practical JSON querying with jq",
    "Good coverage of filtering, grouping, and verbosity options",
    "Parallel processing control is documented with use case guidance",
    "Cache management section with clear examples",
    "Threshold presets are well-explained with a helpful comparison table (lines 92-98)",
    "Monorepo analysis example included",
    "Previous CLI syntax errors (--output-format, --target-location) have been corrected"
  ],
  "improvement_suggestions": [
    "Add 'Quick Reference' section at top with most common command patterns for fast lookup",
    "Include more real-world workflow combinations (analyze → compare → validate → commit cycle)",
    "Expand jq examples for programmatic JSON parsing (extract specific metrics, filter by criteria)",
    "Add examples of reading and acting on debtmap exit codes in CI scripts",
    "Include performance benchmarks or guidance on expected analysis times for different project sizes",
    "Add example .debtmap.toml configurations for popular frameworks (actix-web, tokio, axum, Django, Express)",
    "Consider adding a comparison table showing which options work together vs mutually exclusive",
    "Add troubleshooting subsection for example-specific issues (coverage path mismatches, permission errors)",
    "Include more monorepo-specific patterns (analyzing multiple packages, comparing across packages)",
    "Add examples of environment variable usage (DEBTMAP_CACHE_DIR, DEBTMAP_JOBS, DEBTMAP_CONTEXT_AWARE)",
    "Consider adding terminal recordings or screenshots showing actual colored output",
    "Add section on interpreting and acting on different risk categories (Critical, High, Medium, Low)",
    "Include examples of custom aggregation method usage with explanation of when to use each",
    "Add workflow for progressive refactoring: baseline → fix top 3 → analyze → compare → repeat"
  ],
  "metadata": {
    "analyzed_at": "2025-10-30",
    "feature_inventory": ".prodigy/book-analysis/features.json",
    "topics_covered": [
      "Basic analysis for Rust, Python, JavaScript/TypeScript",
      "Coverage integration with tarpaulin, pytest, Jest",
      "CI/CD integration (GitHub Actions, GitLab CI, CircleCI)",
      "Output formats (terminal, JSON, markdown)",
      "Advanced features (context-aware, multi-pass, cache management)",
      "Configuration examples with .debtmap.toml",
      "Compare command workflows",
      "God object detection with purity weighting",
      "Filtering, grouping, and verbosity options",
      "Parallel processing control",
      "Threshold presets with comparison table",
      "Validation command for quality gates"
    ],
    "validation_focus": "Ensure examples use current CLI syntax and options",
    "example_count_approximate": 60,
    "code_block_count_approximate": 40,
    "lines_analyzed": 1075
  }
}
