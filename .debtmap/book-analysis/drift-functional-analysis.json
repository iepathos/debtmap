{
  "chapter_id": "functional-analysis",
  "chapter_title": "Functional Composition Analysis",
  "chapter_file": "book/src/functional-analysis.md",
  "drift_detected": true,
  "severity": "critical",
  "quality_assessment": "Chapter is completely missing - this is a significant documentation gap for a major feature",
  "issues": [
    {
      "type": "missing_content",
      "severity": "critical",
      "section": "Entire Chapter",
      "description": "The functional composition analysis chapter is completely missing from the book",
      "should_add": "Complete chapter documenting AST-based functional pattern detection, purity analysis, composition metrics, and scoring",
      "fix_suggestion": "Create comprehensive chapter covering: 1) Introduction to functional analysis, 2) Pipeline detection, 3) Purity metrics, 4) Configuration profiles, 5) Integration with scoring, 6) Examples and use cases",
      "source_reference": "src/analysis/functional_composition.rs (entire module)"
    },
    {
      "type": "missing_content",
      "severity": "critical",
      "section": "AST-Based Pipeline Detection",
      "description": "No documentation of the AST-based pipeline detection feature",
      "should_add": "Document pipeline detection including: iterator chains, map/filter/fold patterns, parallel iteration, terminal operations, nested pipelines, builder pattern detection",
      "fix_suggestion": "Add section explaining how debtmap detects functional pipelines through AST analysis, with examples of detected patterns and what makes a valid pipeline",
      "source_reference": "src/analysis/functional_composition.rs:239-287 (detect_pipelines, collect_pipelines)"
    },
    {
      "type": "missing_content",
      "severity": "critical",
      "section": "Purity Analysis",
      "description": "No documentation of purity analysis and side effect detection",
      "should_add": "Document purity analysis covering: pure/probably pure/impure classification, side effect detection (I/O, mutations, unsafe), purity scoring (0.0-1.0), immutability ratio calculation",
      "fix_suggestion": "Add section on purity analysis explaining how debtmap classifies functions as pure/impure, what side effects are detected, and how purity scores are calculated. Include examples of pure vs impure functions.",
      "source_reference": "src/organization/purity_analyzer.rs (PurityLevel, PurityAnalyzer), src/analyzers/purity_detector.rs (PurityDetector), src/analysis/functional_composition.rs:151-165 (PurityMetrics)"
    },
    {
      "type": "missing_content",
      "severity": "high",
      "section": "Configuration Profiles",
      "description": "Three purity profiles (strict, balanced, lenient) are not documented",
      "should_add": "Document the three configuration profiles: strict (min_pipeline_depth=3, max_closure_complexity=3, purity_threshold=0.9), balanced (default: depth=2, complexity=5, purity=0.8), lenient (depth=2, complexity=10, purity=0.5)",
      "fix_suggestion": "Add section explaining when to use each profile: strict for functional-first codebases, balanced for typical Rust projects, lenient for imperative-heavy legacy code. Include table comparing thresholds.",
      "source_reference": "src/analysis/functional_composition.rs:15-74 (FunctionalAnalysisConfig::strict/balanced/lenient)"
    },
    {
      "type": "missing_content",
      "severity": "high",
      "section": "Pipeline Stages",
      "description": "Pipeline stage types are not documented",
      "should_add": "Document all detected pipeline stages: Iterator (iter/into_iter/iter_mut), Map, Filter, Fold, FlatMap, Inspect, AndThen, MapErr. Explain closure complexity tracking and nested pipeline detection.",
      "fix_suggestion": "Add section listing all pipeline stage types with code examples showing each pattern being detected. Explain how closure complexity is measured and how nested pipelines affect analysis.",
      "source_reference": "src/analysis/functional_composition.rs:76-107 (PipelineStage enum)"
    },
    {
      "type": "missing_content",
      "severity": "high",
      "section": "Terminal Operations",
      "description": "Terminal operation detection is not documented",
      "should_add": "Document terminal operations: collect, sum, count, any, all, find, reduce, for_each. Explain how terminal operations complete a pipeline.",
      "fix_suggestion": "Add subsection explaining terminal operations and showing examples of complete pipelines with different terminal operations.",
      "source_reference": "src/analysis/functional_composition.rs:109-120 (TerminalOp enum)"
    },
    {
      "type": "missing_content",
      "severity": "high",
      "section": "Composition Quality Scoring",
      "description": "Composition quality metrics and scoring are not documented",
      "should_add": "Document composition quality scoring including: how pipeline depth, purity score, immutability ratio combine into overall quality score (0.0-1.0), quality thresholds for score boosts, integration with risk scoring",
      "fix_suggestion": "Add section explaining how functional composition quality is calculated from pipeline metrics and purity analysis, and how high-quality functional code receives scoring benefits.",
      "source_reference": "src/analysis/functional_composition.rs:168-180 (CompositionMetrics)"
    },
    {
      "type": "missing_content",
      "severity": "high",
      "section": "Side Effect Classification",
      "description": "Side effect classification (Pure, Benign, Impure) is not documented",
      "should_add": "Document three-level side effect classification: Pure (no side effects), Benign (logging/tracing/metrics - small penalty), Impure (I/O/mutation/network - large penalty)",
      "fix_suggestion": "Add section explaining side effect classification with examples of each category and how they affect purity scoring and risk assessment.",
      "source_reference": "src/analysis/functional_composition.rs:139-148 (SideEffectKind enum)"
    },
    {
      "type": "missing_content",
      "severity": "medium",
      "section": "Purity Weight Multipliers",
      "description": "Purity level weight multipliers for god object scoring are not documented",
      "should_add": "Document purity weight multipliers: Pure (0.3), ProbablyPure (0.5), Impure (1.0). Explain how pure functions contribute less to god object scores, rewarding functional programming patterns.",
      "fix_suggestion": "Add section explaining how purity levels affect god object detection, with examples showing how many small pure helper functions don't trigger god object warnings.",
      "source_reference": "src/organization/purity_analyzer.rs:28-39 (PurityLevel::weight_multiplier)"
    },
    {
      "type": "missing_content",
      "severity": "medium",
      "section": "CLI Integration",
      "description": "CLI flag for functional analysis profile is not documented",
      "should_add": "Document the --functional-analysis-profile flag accepting 'strict', 'balanced', or 'lenient' values",
      "fix_suggestion": "Add section on CLI usage showing how to enable functional analysis and select a profile: debtmap analyze . --functional-analysis-profile balanced",
      "source_reference": "src/cli.rs:304 (functional_analysis_profile option)"
    },
    {
      "type": "missing_content",
      "severity": "medium",
      "section": "Parallel Pipeline Detection",
      "description": "Detection of parallel iteration (par_iter) is not documented",
      "should_add": "Document detection of parallel iteration using rayon's par_iter, indicating high-performance functional patterns",
      "fix_suggestion": "Add subsection on parallel pipeline detection explaining how par_iter() and other parallel iterators are identified and how they affect quality scoring.",
      "source_reference": "src/analysis/functional_composition.rs:129 (Pipeline::is_parallel field)"
    },
    {
      "type": "missing_content",
      "severity": "medium",
      "section": "Builder Pattern Filtering",
      "description": "Builder pattern detection to avoid false positives is not documented",
      "should_add": "Document how debtmap distinguishes builder patterns from functional pipelines to avoid false positives in pattern detection",
      "fix_suggestion": "Add note explaining that builder patterns (method chaining for construction) are filtered out to avoid counting them as functional pipelines.",
      "source_reference": "src/analysis/functional_composition.rs:136 (Pipeline::builder_pattern field)"
    },
    {
      "type": "missing_content",
      "severity": "medium",
      "section": "Immutability Ratio",
      "description": "Immutability ratio calculation is not documented",
      "should_add": "Document immutability ratio: ratio of immutable bindings to total bindings, used in purity scoring",
      "fix_suggestion": "Add explanation of how debtmap calculates immutability ratio by counting let vs let mut bindings, and how this contributes to purity scores.",
      "source_reference": "src/analysis/functional_composition.rs:174 (CompositionMetrics::immutability_ratio)"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Specification Reference",
      "description": "Specification 111 (AST-Based Functional Pattern Detection) is not referenced",
      "should_add": "Reference to spec 111 with accuracy targets: precision ≥90%, recall ≥85%, F1 ≥0.87, performance overhead <10%",
      "fix_suggestion": "Add note referencing spec 111 and its quality targets, potentially in an 'Implementation Details' section.",
      "source_reference": "tests/functional_composition_validation_test.rs:1-5 (spec 111 comment)"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Closure Complexity Tracking",
      "description": "Closure complexity tracking within pipeline stages is not documented",
      "should_add": "Document how closure complexity is measured for map/filter/fold closures and how max_closure_complexity threshold affects analysis",
      "fix_suggestion": "Add detail explaining that complex closures in pipelines can indicate code smell, and how the max_closure_complexity config controls this detection.",
      "source_reference": "src/analysis/functional_composition.rs:82-94 (closure_complexity fields in PipelineStage variants)"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Nested Pipeline Detection",
      "description": "Nested pipeline detection (pipelines within closures) is not documented",
      "should_add": "Document detection of nested pipelines (pipelines inside map/filter closures) and how nesting_level affects analysis",
      "fix_suggestion": "Add note about nested pipeline detection for identifying highly functional code patterns with multiple levels of composition.",
      "source_reference": "src/analysis/functional_composition.rs:84-89 (has_nested_pipeline fields), src/analysis/functional_composition.rs:134 (Pipeline::nesting_level)"
    },
    {
      "type": "missing_content",
      "severity": "low",
      "section": "Use Cases and Examples",
      "description": "No examples or use cases for functional analysis are provided",
      "should_add": "Practical examples showing: detecting imperative vs functional code, identifying refactoring opportunities, using profiles for different codebases, interpreting purity scores",
      "fix_suggestion": "Add 'Examples' section with 3-5 code examples showing functional vs imperative patterns and how debtmap analyzes them. Include output samples and interpretation guidance.",
      "source_reference": "tests/functional_composition_validation_test.rs (various test cases showing expected behavior)"
    }
  ],
  "positive_aspects": [],
  "improvement_suggestions": [
    "Create comprehensive chapter structure covering all aspects of functional composition analysis",
    "Include comparison table of the three configuration profiles",
    "Add visual diagrams showing how pipelines are detected and scored",
    "Provide decision tree for choosing the right profile",
    "Include troubleshooting section for common issues",
    "Add examples from real Rust codebases showing functional patterns",
    "Link to related chapters: scoring strategies, god object detection, complexity analysis",
    "Include performance impact discussion (spec 111 targets <10% overhead)",
    "Add best practices for writing functional Rust code that scores well",
    "Provide migration guide for enabling functional analysis on existing projects"
  ],
  "metadata": {
    "analyzed_at": "2025-10-26",
    "feature_inventory": ".debtmap/book-analysis/features.json",
    "topics_covered": [],
    "validation_focus": "Check that functional composition analysis features are documented",
    "source_features": [
      "src/analysis/functional_composition.rs - Main analysis module",
      "src/organization/purity_analyzer.rs - Purity classification",
      "src/analyzers/purity_detector.rs - Side effect detection",
      "src/refactoring/patterns/functional_patterns.rs - Pattern matchers",
      "tests/functional_composition_validation_test.rs - Specification 111 validation"
    ],
    "implementation_status": "Feature fully implemented with comprehensive tests and validation",
    "documentation_status": "Completely missing - critical documentation gap"
  }
}
