<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debtmap Analysis Dashboard - {{{PROJECT_NAME}}}</title>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body { font-family: 'Inter', system-ui, sans-serif; }
        .metric-card {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            border-left: 4px solid;
            transition: transform 0.2s;
        }
        .metric-card:hover { transform: scale(1.05); }
        .metric-card.critical { border-left-color: #EF4444; }
        .metric-card.high { border-left-color: #F59E0B; }
        .metric-card.medium { border-left-color: #FBBF24; }
        .metric-card.low { border-left-color: #10B981; }

        .chart-container {
            position: relative;
            height: 300px;
            margin-bottom: 2rem;
        }

        table.sortable th {
            cursor: pointer;
            user-select: none;
        }

        table.sortable th:hover {
            background-color: #f3f4f6;
        }

        table.sortable th.sorted-asc::after {
            content: ' ‚ñ≤';
        }

        table.sortable th.sorted-desc::after {
            content: ' ‚ñº';
        }

        .recommendation-card {
            border-left: 4px solid #e5e7eb;
            padding: 1rem;
            background: #f9fafb;
            border-radius: 0.5rem;
            transition: all 0.2s;
        }

        .recommendation-card:hover {
            background: #f3f4f6;
            border-left-color: #8B5CF6;
        }

        .recommendation-card.expanded {
            background: white;
            border-left-color: #8B5CF6;
        }

        .recommendation-card.critical {
            border-left-color: #EF4444;
        }

        .recommendation-card.high {
            border-left-color: #F59E0B;
        }

        .recommendation-card.medium {
            border-left-color: #FBBF24;
        }

        .recommendation-details {
            display: none;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #e5e7eb;
        }

        .recommendation-details.show {
            display: block;
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .badge.critical {
            background: #FEE2E2;
            color: #991B1B;
        }

        .badge.high {
            background: #FED7AA;
            color: #9A3412;
        }

        .badge.medium {
            background: #FEF3C7;
            color: #92400E;
        }

        .badge.low {
            background: #D1FAE5;
            color: #065F46;
        }

        @media print {
            .no-print { display: none; }
            .chart-container { page-break-inside: avoid; }
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="container mx-auto px-4 py-8 max-w-7xl">

        <!-- Header -->
        <div class="bg-gradient-to-r from-blue-600 to-purple-600 rounded-lg shadow-lg p-8 text-white mb-8">
            <h1 class="text-4xl font-bold mb-2">Debtmap Analysis Dashboard</h1>
            <p class="text-blue-100 mb-4">Technical Debt Analysis for {{{PROJECT_NAME}}}</p>
            <div class="flex flex-wrap gap-4 text-sm">
                <span>üìä {{{TOTAL_ITEMS}}} items analyzed</span>
                <span>üìà Debt Density: {{{DEBT_DENSITY}}} per 1K LOC</span>
                <span>üî¢ {{{TOTAL_FUNCTIONS}}} functions</span>
                <span>üìÖ Generated: {{{TIMESTAMP}}}</span>
            </div>
        </div>

        <!-- Debt Density - Prominent Card -->
        <div class="bg-white rounded-lg shadow-lg p-8 mb-8 border-l-8 border-purple-600">
            <div class="flex items-center justify-between">
                <div class="flex-1">
                    <div class="text-sm text-gray-600 mb-2 uppercase tracking-wide">Debt Density</div>
                    <div class="flex items-baseline gap-2 mb-4">
                        <div class="text-6xl font-bold text-purple-600">{{{DEBT_DENSITY}}}</div>
                        <div class="text-2xl text-gray-500 font-medium">per 1K LOC</div>
                    </div>
                    <div class="grid grid-cols-2 gap-4 text-sm text-gray-700">
                        <div>
                            <span class="font-medium text-gray-600">Total Debt Score:</span>
                            <span class="ml-2 font-semibold" id="total-debt-score">-</span>
                        </div>
                        <div>
                            <span class="font-medium text-gray-600">Total LOC:</span>
                            <span class="ml-2 font-semibold" id="total-loc">-</span>
                        </div>
                        <div>
                            <span class="font-medium text-gray-600">Total Items:</span>
                            <span class="ml-2 font-semibold">{{{TOTAL_ITEMS}}}</span>
                        </div>
                        <div>
                            <span class="font-medium text-gray-600">Functions:</span>
                            <span class="ml-2 font-semibold">{{{TOTAL_FUNCTIONS}}}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Key Metrics Cards -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
            <div class="metric-card critical">
                <div class="text-sm text-gray-600 mb-2">Critical Issues</div>
                <div class="text-3xl font-bold text-red-600">{{{CRITICAL_COUNT}}}</div>
                <div class="text-xs text-gray-500 mt-1" id="critical-percentage"></div>
            </div>
            <div class="metric-card high">
                <div class="text-sm text-gray-600 mb-2">High Priority</div>
                <div class="text-3xl font-bold text-orange-600">{{{HIGH_COUNT}}}</div>
                <div class="text-xs text-gray-500 mt-1" id="high-percentage"></div>
            </div>
            <div class="metric-card medium">
                <div class="text-sm text-gray-600 mb-2">Medium Priority</div>
                <div class="text-3xl font-bold text-yellow-600">{{{MEDIUM_COUNT}}}</div>
                <div class="text-xs text-gray-500 mt-1" id="medium-percentage"></div>
            </div>
            <div class="metric-card low">
                <div class="text-sm text-gray-600 mb-2">Low Priority</div>
                <div class="text-3xl font-bold text-green-600">{{{LOW_COUNT}}}</div>
                <div class="text-xs text-gray-500 mt-1" id="low-percentage"></div>
            </div>
        </div>

        <!-- Top 10 Recommendations -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-8">
            <h2 class="text-2xl font-semibold flex items-center gap-2 mb-4">
                <span>üéØ</span> Top 10 Priority Recommendations
            </h2>
            <div id="top-recommendations" class="space-y-4">
                <!-- Populated by JavaScript -->
            </div>
        </div>

        <!-- Charts Section -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
            <!-- Complexity Scatter -->
            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-xl font-semibold mb-4">Cyclomatic vs Cognitive Complexity</h2>
                <div class="chart-container">
                    <canvas id="complexityScatter"></canvas>
                </div>
            </div>

            <!-- Adjusted Complexity Scatter -->
            <div class="bg-white rounded-lg shadow-md p-6" id="adjustedComplexityScatterSection">
                <h2 class="text-xl font-semibold mb-4">Entropy-Adjusted Cyclomatic vs Cognitive</h2>
                <div class="chart-container">
                    <canvas id="adjustedComplexityScatter"></canvas>
                </div>
            </div>

            <!-- Recommendations -->
            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-xl font-semibold mb-4">Top Recommendations</h2>
                <div class="chart-container">
                    <canvas id="recommendationsChart"></canvas>
                </div>
            </div>

            <!-- Root Causes -->
            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-xl font-semibold mb-4">Root Causes</h2>
                <div class="chart-container">
                    <canvas id="rootCausesChart"></canvas>
                </div>
            </div>

            <!-- Entropy Distribution -->
            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-xl font-semibold mb-4">Entropy Distribution</h2>
                <div class="chart-container">
                    <canvas id="entropyDistChart"></canvas>
                </div>
            </div>

            <!-- Entropy-Adjusted Complexity Distribution -->
            <div class="bg-white rounded-lg shadow-md p-6" id="adjustedComplexitySection">
                <h2 class="text-xl font-semibold mb-4">Entropy-Adjusted Complexity</h2>
                <div class="chart-container">
                    <canvas id="adjustedComplexityChart"></canvas>
                </div>
            </div>
        </div>

        <!-- God Objects Table -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-8" id="godObjectsSection" style="display: none;">
            <h2 class="text-xl font-semibold mb-4">üèõÔ∏è God Objects (Architectural Debt)</h2>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200 sortable" id="godObjectsTable">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">File</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Score</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">LOC</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Functions</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Responsibilities</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200" id="godObjectsBody">
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Complex Functions Table -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-8">
            <h2 class="text-xl font-semibold mb-4">üî• Most Complex Functions</h2>

            <!-- Filters -->
            <div class="mb-6 p-4 bg-gray-50 rounded-lg">
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                    <div>
                        <label class="block text-xs font-semibold text-gray-700 mb-2">Search</label>
                        <input type="text" id="searchBox" placeholder="Filter by name or file..."
                               class="px-3 py-2 border border-gray-300 rounded-md w-full text-sm">
                    </div>
                    <div>
                        <label class="block text-xs font-semibold text-gray-700 mb-2">Priority</label>
                        <select id="priorityFilter" class="px-3 py-2 border border-gray-300 rounded-md w-full text-sm">
                            <option value="all">All Priorities</option>
                            <option value="critical">Critical</option>
                            <option value="high">High</option>
                            <option value="medium">Medium</option>
                            <option value="low">Low</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-xs font-semibold text-gray-700 mb-2">Min Complexity</label>
                        <input type="number" id="minComplexity" placeholder="0" min="0"
                               class="px-3 py-2 border border-gray-300 rounded-md w-full text-sm">
                    </div>
                    <div>
                        <label class="block text-xs font-semibold text-gray-700 mb-2">Min Entropy</label>
                        <input type="number" id="minEntropy" placeholder="0.0" min="0" max="1" step="0.1"
                               class="px-3 py-2 border border-gray-300 rounded-md w-full text-sm">
                    </div>
                </div>
                <div class="mt-3 flex gap-2">
                    <button onclick="applyFilters()" class="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 text-sm">
                        Apply Filters
                    </button>
                    <button onclick="resetFilters()" class="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 text-sm">
                        Reset
                    </button>
                </div>
            </div>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200 sortable" id="complexFunctionsTable">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Function</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">File</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Cyclomatic</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Cognitive</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Nesting</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Entropy</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Dampening</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Priority</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200" id="complexFunctionsBody">
                    </tbody>
                </table>
            </div>
        </div>

    </div>

    <!-- Embedded JSON data (safely escaped) -->
    <script id="debt-data" type="application/json">{{{JSON_DATA}}}</script>

    <script>
        const debtData = JSON.parse(document.getElementById('debt-data').textContent);

        // Calculate percentages for metric cards
        const totalItems = {{{TOTAL_ITEMS}}};
        if (totalItems > 0) {
            document.getElementById('critical-percentage').textContent =
                `${({{{CRITICAL_COUNT}}} / totalItems * 100).toFixed(1)}% of items`;
            document.getElementById('high-percentage').textContent =
                `${({{{HIGH_COUNT}}} / totalItems * 100).toFixed(1)}% of items`;
            document.getElementById('medium-percentage').textContent =
                `${({{{MEDIUM_COUNT}}} / totalItems * 100).toFixed(1)}% of items`;
            document.getElementById('low-percentage').textContent =
                `${({{{LOW_COUNT}}} / totalItems * 100).toFixed(1)}% of items`;
        }

        // Calculate and display total debt score
        function calculateTotalDebtScore() {
            // Handle both unified and legacy formats
            const isUnifiedFormat = debtData.format_version !== undefined;

            if (isUnifiedFormat) {
                // Unified format has summary
                const summary = debtData.summary || {};
                document.getElementById('total-debt-score').textContent = Math.round(summary.total_debt_score || 0).toLocaleString();
                document.getElementById('total-loc').textContent = (summary.total_loc || 0).toLocaleString();
            } else {
                // Legacy format - calculate from items
                let totalScore = 0;
                let totalLoc = 0;

                (debtData.technical_debt?.items || []).forEach(item => {
                    const score = item.unified_score?.final_score || 0;
                    totalScore += score;
                });

                (debtData.complexity?.metrics || []).forEach(m => {
                    totalLoc += m.length || 0;
                });

                document.getElementById('total-debt-score').textContent = Math.round(totalScore).toLocaleString();
                document.getElementById('total-loc').textContent = totalLoc.toLocaleString();
            }
        }

        calculateTotalDebtScore();

        // Helper functions for data extraction
        function getDebtItems(data) {
            const isUnifiedFormat = data.format_version !== undefined;
            if (isUnifiedFormat) {
                return data.items || [];
            } else {
                return data.technical_debt?.items || [];
            }
        }

        // Helper to unwrap items based on format
        function unwrapItem(item, data) {
            const isUnifiedFormat = data.format_version !== undefined;

            if (isUnifiedFormat) {
                // Unified format: return item as-is with type info
                return {
                    unwrapped: item,
                    itemType: item.type,
                    isUnified: true
                };
            } else {
                // Legacy format: check for Function/File wrappers
                if (item.Function) {
                    return { unwrapped: item.Function, itemType: 'Function', isUnified: false };
                } else if (item.File) {
                    return { unwrapped: item.File, itemType: 'File', isUnified: false };
                } else {
                    return { unwrapped: item, itemType: null, isUnified: false };
                }
            }
        }

        // Generate distinct colors for any number of categories
        function generateDistinctColors(count) {
            // Predefined palette optimized for maximum visual contrast between adjacent colors
            // Colors are ordered to alternate hue/saturation for better visual separation
            const predefinedColors = [
                '#EF4444', // Red
                '#3B82F6', // Blue
                '#F59E0B', // Orange
                '#10B981', // Green
                '#8B5CF6', // Purple
                '#EAB308', // Yellow
                '#EC4899', // Pink
                '#14B8A6', // Teal
                '#F97316', // Deep Orange
                '#6366F1', // Indigo
                '#84CC16', // Lime
                '#06B6D4', // Cyan
                '#D946EF', // Fuchsia
                '#F43F5E', // Rose
                '#A855F7', // Violet
            ];

            // If we need more colors than predefined, generate them using HSL
            if (count <= predefinedColors.length) {
                return predefinedColors.slice(0, count);
            }

            const colors = [...predefinedColors];
            const hueStep = 360 / (count - predefinedColors.length);

            for (let i = predefinedColors.length; i < count; i++) {
                const hue = (i - predefinedColors.length) * hueStep;
                const saturation = 65 + (i % 3) * 10; // Vary saturation slightly
                const lightness = 50 + (i % 2) * 5;   // Vary lightness slightly
                colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
            }

            return colors;
        }

        function extractRootCausesAndCounts(data) {
            const causes = {};

            // Extract and categorize issues from debt items
            const items = getDebtItems(data);
            items.forEach(item => {
                const { unwrapped } = unwrapItem(item, data);

                let cause = 'Other';
                // Get text from either unified format (recommendation.action) or legacy (message)
                const text = unwrapped.recommendation?.action || unwrapped.recommendation?.primary_action || unwrapped.message || '';

                // Categorize based on recommendation/message patterns
                if (text.includes('nesting') || text.toLowerCase().includes('reduce nesting')) {
                    cause = 'Deep nesting';
                } else if (text.includes('Split') || text.includes('split')) {
                    cause = 'Function/file too large';
                } else if (text.includes('Extract') || text.includes('extract')) {
                    cause = 'Needs extraction';
                } else if (text.includes('Reduce complexity') || text.includes('reduce complexity')) {
                    cause = 'High complexity';
                } else if (text.includes('god object') || text.includes('God Object') || text.includes('GodObject')) {
                    cause = 'God object';
                } else if (text.includes('god module') || text.includes('God Module') || text.includes('GodModule')) {
                    cause = 'God module';
                } else if (text.includes('Standardize') || text.includes('standardize')) {
                    cause = 'Inconsistent patterns';
                } else if (text.includes('dispatcher') || text.includes('state transitions')) {
                    cause = 'Complex control flow';
                } else if (text.includes('duplication') || text.includes('duplicate')) {
                    cause = 'Code duplication';
                } else if (text.includes('testing') || text.includes('coverage')) {
                    cause = 'Testing gaps';
                } else if (text.includes('decision clusters') || text.includes('focused functions')) {
                    cause = 'Multiple responsibilities';
                } else if (text.includes('URGENT')) {
                    cause = 'Critical size violation';
                } else if (text.includes('unbounded growth')) {
                    cause = 'Unbounded collections';
                } else if (text.includes('.unwrap()') || text.includes('.expect(')) {
                    cause = 'Unsafe unwrap/expect';
                } else if (text.includes('.ok()') || text.includes('discarding error')) {
                    cause = 'Error information discarded';
                } else if (text.includes('TODO') || text.includes('FIXME')) {
                    cause = 'TODOs/FIXMEs';
                } else if (text.includes('BUG:')) {
                    cause = 'Known bugs';
                }

                causes[cause] = (causes[cause] || 0) + 1;
            });

            // Sort by count and take top 10
            const sorted = Object.entries(causes)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            return {
                labels: sorted.map(x => x[0]),
                counts: sorted.map(x => x[1])
            };
        }

        function extractRootCauses(data) {
            return extractRootCausesAndCounts(data).labels;
        }

        function extractRootCauseCounts(data) {
            return extractRootCausesAndCounts(data).counts;
        }

        function extractComplexityData(data) {
            const critical = [];
            const high = [];
            const medium = [];
            const low = [];

            // Get function metrics from either format
            const isUnifiedFormat = data.format_version !== undefined;
            let functions = [];

            if (isUnifiedFormat) {
                // Unified format: filter items where type='Function'
                functions = (data.items || [])
                    .filter(item => item.type === 'Function')
                    .map(item => ({
                        name: item.location?.function || 'unknown',
                        cyclomatic: item.metrics?.cyclomatic_complexity || 0,
                        cognitive: item.metrics?.cognitive_complexity || 0
                    }));
            } else {
                // Legacy format
                functions = (data.complexity?.metrics || []).map(func => ({
                    name: func.name,
                    cyclomatic: func.cyclomatic,
                    cognitive: func.cognitive
                }));
            }

            functions.forEach(func => {
                const point = {
                    x: func.cyclomatic,
                    y: func.cognitive,
                    name: func.name
                };

                if (func.cyclomatic >= 20 || func.cognitive >= 50) {
                    critical.push(point);
                } else if (func.cyclomatic >= 15 || func.cognitive >= 30) {
                    high.push(point);
                } else if (func.cyclomatic >= 10 || func.cognitive >= 20) {
                    medium.push(point);
                } else {
                    low.push(point);
                }
            });

            return [
                { label: 'Critical', data: critical, backgroundColor: '#EF4444' },
                { label: 'High', data: high, backgroundColor: '#F59E0B' },
                { label: 'Medium', data: medium, backgroundColor: '#FBBF24' },
                { label: 'Low', data: low, backgroundColor: '#10B981' }
            ];
        }

        function extractAdjustedComplexityData(data) {
            const critical = [];
            const high = [];
            const medium = [];
            const low = [];

            // Get function metrics from either format
            const isUnifiedFormat = data.format_version !== undefined;
            let functions = [];

            if (isUnifiedFormat) {
                // Unified format: filter items where type='Function'
                functions = (data.items || [])
                    .filter(item => item.type === 'Function')
                    .filter(item => item.adjusted_complexity?.dampened_cyclomatic) // Only include functions with adjusted complexity
                    .map(item => ({
                        name: item.location?.function || 'unknown',
                        cyclomatic: item.adjusted_complexity.dampened_cyclomatic,
                        cognitive: item.metrics?.cognitive_complexity || 0
                    }));
            } else {
                // Legacy format
                const items = data.items || [];
                functions = items
                    .filter(item => item.Function)
                    .filter(item => item.Function.debt_type?.ComplexityHotspot?.adjusted_cyclomatic)
                    .map(item => {
                        const func = item.Function;
                        return {
                            name: func.location?.function || func.name || 'unknown',
                            cyclomatic: func.debt_type.ComplexityHotspot.adjusted_cyclomatic,
                            cognitive: func.cognitive_complexity || 0
                        };
                    });
            }

            // If no adjusted complexity data, return null
            if (functions.length === 0) {
                return null;
            }

            functions.forEach(func => {
                const point = {
                    x: func.cyclomatic,
                    y: func.cognitive,
                    name: func.name
                };

                if (func.cyclomatic >= 20 || func.cognitive >= 50) {
                    critical.push(point);
                } else if (func.cyclomatic >= 15 || func.cognitive >= 30) {
                    high.push(point);
                } else if (func.cyclomatic >= 10 || func.cognitive >= 20) {
                    medium.push(point);
                } else {
                    low.push(point);
                }
            });

            return [
                { label: 'Critical', data: critical, backgroundColor: '#EF4444' },
                { label: 'High', data: high, backgroundColor: '#F59E0B' },
                { label: 'Medium', data: medium, backgroundColor: '#FBBF24' },
                { label: 'Low', data: low, backgroundColor: '#10B981' }
            ];
        }

        function extractRecommendations(data) {
            const recommendations = {};
            const items = getDebtItems(data);

            items.forEach(item => {
                const { unwrapped } = unwrapItem(item, data);

                // Try to extract from recommendation.action first, then fall back to message
                const rec = unwrapped.recommendation?.action ||
                           unwrapped.recommendation?.primary_action ||
                           (unwrapped.message?.split(':')[0]) ||
                           unwrapped.category ||
                           'Other';
                recommendations[rec] = (recommendations[rec] || 0) + 1;
            });
            const sorted = Object.entries(recommendations).sort((a, b) => b[1] - a[1]);
            return sorted.slice(0, 6).map(x => x[0]);
        }

        function extractRecommendationCounts(data) {
            const recommendations = {};
            const items = getDebtItems(data);

            items.forEach(item => {
                const { unwrapped } = unwrapItem(item, data);

                // Try to extract from recommendation.action first, then fall back to message
                const rec = unwrapped.recommendation?.action ||
                           unwrapped.recommendation?.primary_action ||
                           (unwrapped.message?.split(':')[0]) ||
                           unwrapped.category ||
                           'Other';
                recommendations[rec] = (recommendations[rec] || 0) + 1;
            });
            const sorted = Object.entries(recommendations).sort((a, b) => b[1] - a[1]);
            return sorted.slice(0, 6).map(x => x[1]);
        }

        // Normalize recommendation action for grouping
        function normalizeRecommendation(item) {
            const recommendation = item.recommendation || {};
            const action = recommendation.action || recommendation.primary_action || item.message || '';
            const lowerAction = action.toLowerCase();

            // Group similar recommendations (case-insensitive)
            // Match "Split into X focused functions by decision clusters"
            if (lowerAction.includes('split') && lowerAction.includes('focused') && lowerAction.includes('function') && lowerAction.includes('decision')) {
                return 'Split into focused functions by decision clusters';
            } else if (lowerAction.includes('add tests') || lowerAction.includes('test coverage')) {
                return 'Add tests';
            } else if (lowerAction.includes('extract') && lowerAction.includes('function')) {
                return 'Extract helper functions';
            } else if (lowerAction.includes('reduce nesting')) {
                return 'Reduce nesting depth';
            } else if (lowerAction.includes('god object')) {
                return 'Refactor god object';
            } else if (lowerAction.includes('standardize')) {
                return 'Standardize control flow patterns';
            }

            // Default: use first 50 chars of action
            return action.substring(0, 50);
        }

        // Populate Top 10 Recommendations with grouping
        function populateTop10Recommendations() {
            const allItems = getDebtItems(debtData)
                .map(item => {
                    const { unwrapped, itemType } = unwrapItem(item, debtData);
                    return {
                        ...unwrapped,
                        score: unwrapped.score || unwrapped.unified_score?.final_score || 0,
                        _itemType: itemType  // Track original type
                    };
                })
                .sort((a, b) => b.score - a.score);

            // Group items by normalized recommendation
            const groups = new Map();
            allItems.forEach(item => {
                const normalizedRec = normalizeRecommendation(item);
                if (!groups.has(normalizedRec)) {
                    groups.set(normalizedRec, []);
                }
                groups.get(normalizedRec).push(item);
            });

            // Convert to array and sort by total score
            const groupedRecommendations = Array.from(groups.entries())
                .map(([recommendation, items]) => {
                    const totalScore = items.reduce((sum, item) => sum + item.score, 0);
                    const avgScore = totalScore / items.length;

                    // Find highest individual priority in the group
                    // Items are already sorted by score, so first item has highest priority
                    const highestPriority = items[0].priority;

                    return {
                        recommendation,
                        items,
                        totalScore,
                        avgScore,
                        count: items.length,
                        // Use highest individual item priority (not calculated from total)
                        priority: highestPriority
                    };
                })
                .sort((a, b) => b.totalScore - a.totalScore)
                .slice(0, 10);

            const container = document.getElementById('top-recommendations');

            groupedRecommendations.forEach((group, groupIndex) => {
                const card = document.createElement('div');
                const priorityClass = group.priority;
                card.className = `recommendation-card ${priorityClass}`;

                // Build HTML for the group
                let groupHtml = `
                    <div class="flex items-start justify-between cursor-pointer" onclick="toggleGroupDetails(${groupIndex})">
                        <div class="flex-1">
                            <div class="flex items-center gap-3 mb-2">
                                <span class="text-lg font-bold text-gray-700">#${groupIndex + 1}</span>
                                <span class="badge ${priorityClass}">${group.priority.toUpperCase()}</span>
                                <span class="text-sm font-semibold text-purple-600">TOTAL SCORE: ${Math.round(group.totalScore)}</span>
                                ${group.count > 1 ? `<span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded-full font-semibold">${group.count} items</span>` : ''}
                            </div>
                            <div class="text-sm text-gray-800 font-medium">‚ö° ${group.recommendation}</div>
                            ${group.count > 1 ? `<div class="text-xs text-gray-600 mt-1">Average score: ${Math.round(group.avgScore)}</div>` : ''}
                        </div>
                        <button class="text-gray-400 hover:text-gray-600 ml-4">
                            <span id="group-toggle-icon-${groupIndex}">‚ñº</span>
                        </button>
                    </div>
                    <div id="group-details-${groupIndex}" class="recommendation-details">
                `;

                // If only one item, show its details directly
                if (group.count === 1) {
                    const item = group.items[0];
                    const recommendation = item.recommendation || {};
                    const impact = item.impact || item.expected_impact || {};
                    const metrics = item.metrics || {};

                    // Handle location
                    let locationText = '';
                    if (item.location) {
                        locationText = item.location.file || '';
                        if (item.location.line) locationText += `:${item.location.line}`;
                        if (item.location.function) locationText += ` ${item.location.function}()`;
                    } else if (item._itemType === 'File' && metrics.path) {
                        locationText = metrics.path;
                    } else {
                        locationText = item.file || '';
                        if (item.line) locationText += `:${item.line}`;
                        if (item.function_name) locationText += ` ${item.function_name}()`;
                    }

                    const entropy = metrics.entropy_score || item.entropy_score;
                    const entropyDisplay = entropy !== null && entropy !== undefined ? entropy.toFixed(2) : 'N/A';
                    const entropyColor = getEntropyColorClass(entropy);

                    let dampeningDisplay = 'N/A';
                    if (item.adjusted_complexity?.dampened_cyclomatic && metrics.cyclomatic_complexity) {
                        const dampening = item.adjusted_complexity.dampened_cyclomatic / metrics.cyclomatic_complexity;
                        dampeningDisplay = dampening.toFixed(2);
                    }

                    const rationale = recommendation.rationale || item.context?.rationale || extractRationaleFromMessage(item.message);

                    groupHtml += `
                        <div class="mb-2">
                            <div class="text-sm font-mono text-gray-600">${locationText}</div>
                        </div>
                        ${rationale ? `
                            <div class="mb-3 bg-blue-50 border-l-4 border-blue-400 p-3 rounded">
                                <div class="text-xs font-semibold text-blue-900 uppercase mb-1">üí° Why This Matters</div>
                                <div class="text-sm text-blue-900">${rationale}</div>
                            </div>
                        ` : ''}
                        ${impact.complexity_reduction || impact.risk_reduction ? `
                            <div class="mb-3">
                                <div class="text-xs font-semibold text-gray-600 uppercase mb-1">üìà Impact</div>
                                <div class="text-sm text-gray-700 space-y-1">
                                    ${impact.complexity_reduction ? `<div>‚Ä¢ Complexity reduction: ${impact.complexity_reduction.toFixed(1)}</div>` : ''}
                                    ${impact.risk_reduction ? `<div>‚Ä¢ Risk reduction: ${impact.risk_reduction.toFixed(1)}</div>` : ''}
                                </div>
                            </div>
                        ` : ''}
                        ${metrics.cyclomatic_complexity || metrics.cognitive_complexity || entropy !== null ? `
                            <div class="mb-3">
                                <div class="text-xs font-semibold text-gray-600 uppercase mb-1">üìä Metrics</div>
                                <div class="text-sm text-gray-700">
                                    <div class="grid grid-cols-2 gap-2">
                                        ${metrics.cyclomatic_complexity ? `<div>Cyclomatic: <span class="font-semibold">${metrics.cyclomatic_complexity}</span></div>` : ''}
                                        ${metrics.cognitive_complexity ? `<div>Cognitive: <span class="font-semibold">${metrics.cognitive_complexity}</span></div>` : ''}
                                        ${metrics.nesting_depth ? `<div>Nesting: <span class="font-semibold">${metrics.nesting_depth}</span></div>` : ''}
                                        ${entropy !== null && entropy !== undefined ? `<div>Entropy: <span class="font-semibold ${entropyColor}">${entropyDisplay}</span></div>` : ''}
                                        ${dampeningDisplay !== 'N/A' ? `<div>Dampening: <span class="font-semibold text-blue-600">${dampeningDisplay}</span></div>` : ''}
                                    </div>
                                </div>
                            </div>
                        ` : ''}
                        ${item.message ? `
                            <div class="mb-3">
                                <div class="text-xs font-semibold text-gray-600 uppercase mb-1">üìã Details</div>
                                <div class="text-xs text-gray-600 p-2 bg-gray-50 rounded">
                                    ${item.message}
                                </div>
                            </div>
                        ` : ''}
                        ${item.god_object_indicators?.recommended_splits ? renderGodObjectSplits(item.god_object_indicators) : ''}
                    `;
                } else {
                    // Multiple items - show Why This Matters and aggregated info
                    const topItem = group.items[0]; // Highest scoring item
                    const topRecommendation = topItem.recommendation || {};
                    const topRationale = topRecommendation.rationale || topItem.context?.rationale || extractRationaleFromMessage(topItem.message);

                    // Calculate aggregated impact
                    let totalComplexityReduction = 0;
                    let totalRiskReduction = 0;
                    group.items.forEach(item => {
                        const impact = item.impact || item.expected_impact || {};
                        totalComplexityReduction += impact.complexity_reduction || 0;
                        totalRiskReduction += impact.risk_reduction || 0;
                    });

                    // Show Why This Matters from the top-scoring item
                    if (topRationale) {
                        groupHtml += `
                            <div class="mb-3 bg-blue-50 border-l-4 border-blue-400 p-3 rounded">
                                <div class="text-xs font-semibold text-blue-900 uppercase mb-1">üí° Why This Matters</div>
                                <div class="text-sm text-blue-900">${topRationale}</div>
                            </div>
                        `;
                    }

                    // Show aggregated impact
                    if (totalComplexityReduction > 0 || totalRiskReduction > 0) {
                        groupHtml += `
                            <div class="mb-3">
                                <div class="text-xs font-semibold text-gray-600 uppercase mb-1">üìà Aggregated Impact (${group.count} items)</div>
                                <div class="text-sm text-gray-700 space-y-1">
                                    ${totalComplexityReduction > 0 ? `<div>‚Ä¢ Total complexity reduction: <span class="font-semibold text-green-600">${totalComplexityReduction.toFixed(1)}</span></div>` : ''}
                                    ${totalRiskReduction > 0 ? `<div>‚Ä¢ Total risk reduction: <span class="font-semibold text-green-600">${totalRiskReduction.toFixed(1)}</span></div>` : ''}
                                </div>
                            </div>
                        `;
                    }

                    // Show list of affected locations
                    groupHtml += `
                        <div class="mb-3">
                            <div class="text-xs font-semibold text-gray-600 uppercase mb-2">üìç Affected Locations (${group.count})</div>
                            <div class="space-y-2 max-h-96 overflow-y-auto">
                    `;

                    group.items.slice(0, 20).forEach((item, idx) => {
                        const metrics = item.metrics || {};
                        let locationText = '';
                        if (item.location) {
                            locationText = item.location.file || '';
                            if (item.location.line) locationText += `:${item.location.line}`;
                            if (item.location.function) locationText += ` ${item.location.function}()`;
                        } else if (item._itemType === 'File' && metrics.path) {
                            locationText = metrics.path;
                        } else {
                            locationText = item.file || '';
                            if (item.line) locationText += `:${item.line}`;
                            if (item.function_name) locationText += ` ${item.function_name}()`;
                        }

                        const itemPriorityClass = item.priority.toLowerCase();

                        groupHtml += `
                            <div class="border-l-2 border-${itemPriorityClass === 'critical' ? 'red' : itemPriorityClass === 'high' ? 'orange' : itemPriorityClass === 'medium' ? 'yellow' : 'green'}-400 pl-3 py-1">
                                <div class="flex items-center justify-between">
                                    <div class="text-sm font-mono text-gray-700">${locationText}</div>
                                    <span class="text-xs font-semibold text-purple-600 ml-2">${Math.round(item.score)}</span>
                                </div>
                                ${item.recommendation?.action && item.recommendation.action !== group.recommendation ?
                                    `<div class="text-xs text-gray-600 mt-1">${item.recommendation.action}</div>` : ''}
                            </div>
                        `;
                    });

                    if (group.count > 20) {
                        groupHtml += `<div class="text-xs text-gray-500 italic pl-3">... and ${group.count - 20} more</div>`;
                    }

                    groupHtml += `
                            </div>
                        </div>
                    `;
                }

                groupHtml += `
                    </div>
                `;

                card.innerHTML = groupHtml;
                container.appendChild(card);
            });
        }

        function toggleGroupDetails(index) {
            const details = document.getElementById(`group-details-${index}`);
            const icon = document.getElementById(`group-toggle-icon-${index}`);
            const card = details.parentElement;

            if (details.classList.contains('show')) {
                details.classList.remove('show');
                icon.textContent = '‚ñº';
                card.classList.remove('expanded');
            } else {
                details.classList.add('show');
                icon.textContent = '‚ñ≤';
                card.classList.add('expanded');
            }
        }

        function renderGodObjectSplits(indicators) {
            const splits = indicators.recommended_splits || [];
            if (splits.length === 0) return '';

            const responsibilities = indicators.responsibility_names?.join(', ') || 'N/A';
            const structureInfo = `${indicators.methods_count || 0} methods, ${indicators.fields_count || 0} fields, ${indicators.responsibilities || 0} responsibilities`;

            let html = `
                <div class="mt-4 border-t pt-4">
                    <div class="text-xs font-semibold text-gray-600 uppercase mb-2">üèõÔ∏è God Object Analysis</div>
                    <div class="text-sm text-gray-700 mb-3">
                        <div><strong>Structure:</strong> ${structureInfo}</div>
                        <div><strong>Responsibilities:</strong> ${responsibilities}</div>
                        <div><strong>God Object Score:</strong> ${(indicators.god_object_score * 100).toFixed(0)}%</div>
                    </div>
                    <div class="text-xs font-semibold text-gray-600 uppercase mb-2">üì¶ Recommended Splits (${splits.length} modules)</div>
                    <div class="space-y-3">
            `;

            splits.forEach((split, idx) => {
                const priorityClass = split.priority?.toLowerCase() || 'medium';
                const methods = split.methods_to_move || [];
                const fields = split.fields_needed || [];

                html += `
                    <div class="border border-gray-200 rounded p-3 bg-white">
                        <div class="flex items-start justify-between mb-2">
                            <div class="flex-1">
                                <div class="font-mono text-sm font-semibold text-purple-700">${split.suggested_name}</div>
                                <div class="text-xs text-gray-600 mt-1">
                                    <span class="badge ${priorityClass} mr-2">${split.priority || 'Medium'}</span>
                                    <span>${split.responsibility || split.behavior_category || 'General'}</span>
                                </div>
                            </div>
                            <div class="text-xs text-gray-600">
                                ${split.method_count || methods.length} methods, ~${split.estimated_lines || 0} lines
                            </div>
                        </div>
                        ${methods.length > 0 ? `
                            <div class="mt-2">
                                <div class="text-xs font-semibold text-gray-600 mb-1">Methods (${methods.length}):</div>
                                <div class="text-xs font-mono text-gray-700 space-y-1">
                                    ${methods.slice(0, 5).map(m => `<div>‚Ä¢ ${m}()</div>`).join('')}
                                    ${methods.length > 5 ? `<div class="text-gray-500">... and ${methods.length - 5} more</div>` : ''}
                                </div>
                            </div>
                        ` : ''}
                        ${fields.length > 0 ? `
                            <div class="mt-2">
                                <div class="text-xs font-semibold text-gray-600 mb-1">Fields needed (${fields.length}):</div>
                                <div class="text-xs font-mono text-gray-700">
                                    ${fields.join(', ')}
                                </div>
                            </div>
                        ` : ''}
                        ${split.trait_suggestion ? `
                            <details class="mt-2">
                                <summary class="text-xs font-semibold text-gray-600 cursor-pointer hover:text-purple-600">
                                    View trait suggestion
                                </summary>
                                <pre class="text-xs font-mono bg-gray-50 p-2 rounded mt-1 overflow-x-auto">${split.trait_suggestion}</pre>
                            </details>
                        ` : ''}
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            return html;
        }

        function toggleDetails(index) {
            const details = document.getElementById(`details-${index}`);
            const icon = document.getElementById(`toggle-icon-${index}`);
            const card = details.parentElement;

            if (details.classList.contains('show')) {
                details.classList.remove('show');
                icon.textContent = '‚ñº';
                card.classList.remove('expanded');
            } else {
                details.classList.add('show');
                icon.textContent = '‚ñ≤';
                card.classList.add('expanded');
            }
        }

        function getEntropyColorClass(entropy) {
            if (entropy === null || entropy === undefined || entropy === 'N/A') return '';
            if (entropy >= 0.6) return 'text-red-600';
            if (entropy >= 0.4) return 'text-orange-600';
            if (entropy >= 0.3) return 'text-yellow-600';
            return 'text-green-600';
        }

        function extractRationaleFromMessage(message) {
            if (!message) return null;

            // Try to extract rationale from common patterns in messages
            // Messages often have format like "Issue: details" or contain explanation after first sentence

            // If message contains multiple sentences, use the explanation parts
            const sentences = message.split(/[.!?]+/).filter(s => s.trim().length > 0);
            if (sentences.length > 1) {
                // Return sentences after the first one as rationale
                return sentences.slice(1).join('. ').trim() + '.';
            }

            // If message has a colon, try to extract explanation
            if (message.includes(':')) {
                const parts = message.split(':');
                if (parts.length > 1 && parts[1].trim().length > 20) {
                    return parts.slice(1).join(':').trim();
                }
            }

            // If message is long enough, use it as is
            if (message.length > 50) {
                return message;
            }

            return null;
        }

        populateTop10Recommendations();

        // Root Causes Bar Chart
        const rootCausesData = extractRootCausesAndCounts(debtData);

        if (rootCausesData.labels.length > 0) {
            new Chart(document.getElementById('rootCausesChart'), {
                type: 'bar',
                data: {
                    labels: rootCausesData.labels,
                    datasets: [{
                        label: 'Count',
                        data: rootCausesData.counts,
                        backgroundColor: generateDistinctColors(rootCausesData.labels.length)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${value} items (${percentage}%)`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { precision: 0 },
                            title: { display: true, text: 'Number of Items' }
                        },
                        x: {
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    }
                }
            });
        } else {
            // Show message when no data
            document.getElementById('rootCausesChart').parentElement.innerHTML =
                '<div class="text-center text-gray-500 py-8">No data available. Root causes are extracted from debt item messages.</div>';
        }

        // Complexity Scatter Plot
        new Chart(document.getElementById('complexityScatter'), {
            type: 'scatter',
            data: {
                datasets: extractComplexityData(debtData)
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: { display: true, text: 'Cyclomatic Complexity' },
                        beginAtZero: true
                    },
                    y: {
                        title: { display: true, text: 'Cognitive Complexity' },
                        beginAtZero: true
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.raw.name}: (${context.parsed.x}, ${context.parsed.y})`;
                            }
                        }
                    }
                }
            }
        });

        // Adjusted Complexity Scatter Plot
        const adjustedScatterData = extractAdjustedComplexityData(debtData);
        if (adjustedScatterData) {
            new Chart(document.getElementById('adjustedComplexityScatter'), {
                type: 'scatter',
                data: {
                    datasets: adjustedScatterData
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Entropy-Adjusted Cyclomatic' },
                            beginAtZero: true
                        },
                        y: {
                            title: { display: true, text: 'Cognitive Complexity' },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.raw.name}: (${context.parsed.x}, ${context.parsed.y})`;
                                }
                            }
                        }
                    }
                }
            });
        } else {
            // Hide the section if no adjusted data
            document.getElementById('adjustedComplexityScatterSection').style.display = 'none';
        }

        // Recommendations Horizontal Bar Chart
        const recommendationLabels = extractRecommendations(debtData);
        const recommendationCounts = extractRecommendationCounts(debtData);

        new Chart(document.getElementById('recommendationsChart'), {
            type: 'bar',
            data: {
                labels: recommendationLabels,
                datasets: [{
                    data: recommendationCounts,
                    backgroundColor: generateDistinctColors(recommendationLabels.length)
                }]
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: {
                        left: 10,
                        right: 10
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            title: function(context) {
                                return recommendationLabels[context[0].dataIndex];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        ticks: { precision: 0 }
                    },
                    y: {
                        ticks: {
                            autoSkip: false,
                            callback: function(value, index) {
                                const label = recommendationLabels[index];
                                const maxLength = 35;
                                if (label.length > maxLength) {
                                    return label.substring(0, maxLength) + '...';
                                }
                                return label;
                            }
                        }
                    }
                }
            }
        });

        // Entropy Distribution Chart
        function createEntropyDistribution(data) {
            const entropyBins = [
                { label: '0.0-0.2 (Low)', min: 0.0, max: 0.2, count: 0, color: 'rgba(16, 185, 129, 0.7)' },
                { label: '0.2-0.4 (Medium)', min: 0.2, max: 0.4, count: 0, color: 'rgba(251, 191, 36, 0.7)' },
                { label: '0.4-0.6 (High)', min: 0.4, max: 0.6, count: 0, color: 'rgba(245, 158, 11, 0.7)' },
                { label: '0.6+ (Very High)', min: 0.6, max: 1.0, count: 0, color: 'rgba(239, 68, 68, 0.7)' }
            ];

            const isUnifiedFormat = data.format_version !== undefined;
            let functions = [];

            if (isUnifiedFormat) {
                functions = (data.items || [])
                    .filter(item => item.type === 'Function')
                    .map(item => ({ entropy_score: item.metrics?.entropy_score }));
            } else {
                functions = data.complexity?.metrics || [];
            }

            functions.forEach(func => {
                const entropy = func.entropy_score;
                if (entropy !== null && entropy !== undefined) {
                    for (let bin of entropyBins) {
                        if (entropy >= bin.min && entropy < bin.max) {
                            bin.count++;
                            break;
                        }
                    }
                }
            });

            return {
                labels: entropyBins.map(b => b.label),
                datasets: [{
                    label: 'Functions',
                    data: entropyBins.map(b => b.count),
                    backgroundColor: entropyBins.map(b => b.color),
                    borderColor: entropyBins.map(b => b.color.replace('0.7', '1')),
                    borderWidth: 1
                }]
            };
        }

        new Chart(document.getElementById('entropyDistChart'), {
            type: 'bar',
            data: createEntropyDistribution(debtData),
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: { display: true, text: 'Number of Functions' },
                        ticks: { precision: 0 }
                    },
                    x: {
                        title: { display: true, text: 'Entropy Range' }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.parsed.y} functions`;
                            }
                        }
                    }
                }
            }
        });

        // Entropy-Adjusted Complexity Distribution Chart
        function createAdjustedComplexityDistribution(data) {
            const isUnifiedFormat = data.format_version !== undefined;
            let functions = [];

            if (isUnifiedFormat) {
                functions = (data.items || [])
                    .filter(item => item.type === 'Function')
                    .map(item => ({
                        cyclomatic: item.metrics?.cyclomatic_complexity || 0,
                        adjusted: item.adjusted_complexity?.dampened_cyclomatic || null,
                        entropy: item.metrics?.entropy_score
                    }));
            } else {
                // Legacy format with Function/File wrappers
                const items = data.items || [];
                functions = items
                    .filter(item => item.Function)
                    .map(item => {
                        const func = item.Function;
                        return {
                            cyclomatic: func.cyclomatic_complexity || 0,
                            adjusted: func.debt_type?.ComplexityHotspot?.adjusted_cyclomatic || null,
                            entropy: func.entropy_details?.score || null
                        };
                    });
            }

            // Filter to only functions with adjusted complexity
            const adjusted = functions.filter(f => f.adjusted !== null && f.adjusted !== undefined);

            // If no adjusted complexity data, hide the section
            if (adjusted.length === 0) {
                document.getElementById('adjustedComplexitySection').style.display = 'none';
                return null;
            }

            // Create comparison bins
            const bins = [
                { label: '0-10', min: 0, max: 10, original: 0, adjusted: 0 },
                { label: '10-20', min: 10, max: 20, original: 0, adjusted: 0 },
                { label: '20-30', min: 20, max: 30, original: 0, adjusted: 0 },
                { label: '30+', min: 30, max: Infinity, original: 0, adjusted: 0 }
            ];

            adjusted.forEach(func => {
                for (let bin of bins) {
                    if (func.cyclomatic >= bin.min && func.cyclomatic < bin.max) {
                        bin.original++;
                    }
                    if (func.adjusted >= bin.min && func.adjusted < bin.max) {
                        bin.adjusted++;
                    }
                }
            });

            return {
                labels: bins.map(b => b.label),
                datasets: [
                    {
                        label: 'Original Cyclomatic',
                        data: bins.map(b => b.original),
                        backgroundColor: 'rgba(239, 68, 68, 0.7)',
                        borderColor: 'rgba(239, 68, 68, 1)',
                        borderWidth: 1
                    },
                    {
                        label: 'Entropy-Adjusted',
                        data: bins.map(b => b.adjusted),
                        backgroundColor: 'rgba(16, 185, 129, 0.7)',
                        borderColor: 'rgba(16, 185, 129, 1)',
                        borderWidth: 1
                    }
                ]
            };
        }

        const adjustedComplexityData = createAdjustedComplexityDistribution(debtData);
        if (adjustedComplexityData) {
            new Chart(document.getElementById('adjustedComplexityChart'), {
                type: 'bar',
                data: adjustedComplexityData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Number of Functions' },
                            ticks: { precision: 0 }
                        },
                        x: {
                            title: { display: true, text: 'Complexity Range' }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y} functions`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Filter functionality
        let allFunctions = [];

        function applyFilters() {
            const searchTerm = document.getElementById('searchBox').value.toLowerCase();
            const priority = document.getElementById('priorityFilter').value;
            const minComplexity = parseFloat(document.getElementById('minComplexity').value) || 0;
            const minEntropy = parseFloat(document.getElementById('minEntropy').value) || 0;

            const tbody = document.getElementById('complexFunctionsBody');
            const rows = tbody.getElementsByTagName('tr');

            Array.from(rows).forEach(row => {
                const cells = row.getElementsByTagName('td');
                if (cells.length === 0) return;

                const name = cells[0].textContent.toLowerCase();
                const file = cells[1].textContent.toLowerCase();
                const cyclomatic = parseInt(cells[2].textContent) || 0;
                const cognitive = parseInt(cells[3].textContent) || 0;
                const entropyText = cells[5].textContent;
                const entropy = entropyText === 'N/A' ? 0 : parseFloat(entropyText) || 0;
                const priorityBadge = cells[7].textContent.toLowerCase();

                const matchesSearch = name.includes(searchTerm) || file.includes(searchTerm);
                const matchesPriority = priority === 'all' || priorityBadge.includes(priority);
                const matchesComplexity = Math.max(cyclomatic, cognitive) >= minComplexity;
                const matchesEntropy = entropy >= minEntropy;

                row.style.display = (matchesSearch && matchesPriority && matchesComplexity && matchesEntropy) ? '' : 'none';
            });
        }

        function resetFilters() {
            document.getElementById('searchBox').value = '';
            document.getElementById('priorityFilter').value = 'all';
            document.getElementById('minComplexity').value = '';
            document.getElementById('minEntropy').value = '';
            applyFilters();
        }

        // Auto-apply search filter on input
        document.getElementById('searchBox').addEventListener('input', applyFilters);
        document.getElementById('priorityFilter').addEventListener('change', applyFilters);

        // Populate God Objects Table
        function populateGodObjectsTable() {
            const items = getDebtItems(debtData);

            const godObjects = items.filter(item => {
                const { unwrapped, itemType, isUnified } = unwrapItem(item, debtData);

                if (isUnified) {
                    // Unified format: check category
                    return unwrapped.category === 'GodObject' || unwrapped.category === 'GodModule';
                } else {
                    // Legacy format: check if File item with god object indicators
                    if (itemType === 'File') {
                        const godIndicators = unwrapped.metrics?.god_object_indicators;
                        return godIndicators && godIndicators.is_god_object;
                    }
                    // Or check debt_type for GodObject variant
                    return unwrapped.debt_type === 'GodObject' ||
                           (unwrapped.debt_type && typeof unwrapped.debt_type === 'object' && unwrapped.debt_type.GodObject);
                }
            });

            if (godObjects.length > 0) {
                document.getElementById('godObjectsSection').style.display = 'block';
                const tbody = document.getElementById('godObjectsBody');

                godObjects.forEach(item => {
                    const { unwrapped, itemType } = unwrapItem(item, debtData);

                    // Extract location data from either format
                    const file = unwrapped.location?.file || unwrapped.metrics?.path || unwrapped.file || '-';
                    const line = unwrapped.location?.line || unwrapped.line || '-';
                    const priority = typeof unwrapped.priority === 'string' ? unwrapped.priority : (unwrapped.priority?.toString() || '-');

                    // Extract god object metrics
                    const godIndicators = unwrapped.metrics?.god_object_indicators || unwrapped.god_object_indicators;
                    const methodsCount = godIndicators?.methods_count || '-';
                    const responsibilities = godIndicators?.responsibilities || '-';

                    const row = tbody.insertRow();
                    row.innerHTML = `
                        <td class="px-6 py-4 text-sm font-mono">${file}</td>
                        <td class="px-6 py-4 text-sm font-semibold text-red-600">${priority}</td>
                        <td class="px-6 py-4 text-sm">${line}</td>
                        <td class="px-6 py-4 text-sm">${methodsCount}</td>
                        <td class="px-6 py-4 text-sm text-gray-600">${responsibilities}</td>
                    `;
                });
            }
        }

        // Populate Complex Functions Table
        function populateComplexFunctionsTable() {
            const tbody = document.getElementById('complexFunctionsBody');

            // Get functions from data
            let functions = [];
            const isUnifiedFormat = debtData.format_version !== undefined;

            if (isUnifiedFormat) {
                // In unified format, functions have type='Function'
                functions = (debtData.items || [])
                    .filter(item => item.type === 'Function')
                    .map(item => ({
                        name: item.location?.function || 'unknown',
                        file: item.location?.file || '',
                        cyclomatic: item.metrics?.cyclomatic_complexity || 0,
                        cognitive: item.metrics?.cognitive_complexity || 0,
                        nesting: item.metrics?.nesting_depth || 0,
                        entropy_score: item.metrics?.entropy_score,
                        adjusted_complexity: item.debt_type?.ComplexityHotspot ? {
                            dampened_cyclomatic: item.debt_type.ComplexityHotspot.adjusted_cyclomatic
                        } : null
                    }));
            } else {
                // Legacy format with wrappers
                const items = debtData.technical_debt?.items || [];
                functions = items
                    .filter(item => item.Function)
                    .map(item => {
                        const func = item.Function;
                        return {
                            name: func.location?.function || func.name || 'unknown',
                            file: func.location?.file || func.file || '',
                            cyclomatic: func.metrics?.cyclomatic_complexity || func.cyclomatic || 0,
                            cognitive: func.metrics?.cognitive_complexity || func.cognitive || 0,
                            nesting: func.metrics?.nesting_depth || func.nesting || 0,
                            entropy_score: func.metrics?.entropy_score || func.entropy_score,
                            adjusted_complexity: func.debt_type?.ComplexityHotspot ? {
                                dampened_cyclomatic: func.debt_type.ComplexityHotspot.adjusted_cyclomatic
                            } : null
                        };
                    });

                // Also try old complexity format if no items found
                if (functions.length === 0 && debtData.complexity?.metrics) {
                    functions = debtData.complexity.metrics;
                }
            }

            functions = functions
                .sort((a, b) => Math.max(b.cyclomatic, b.cognitive) - Math.max(a.cyclomatic, a.cognitive))
                .slice(0, 50);

            functions.forEach(func => {
                const row = tbody.insertRow();
                const entropy = func.entropy_score ?? 'N/A';
                const entropyDisplay = entropy !== 'N/A' ? entropy.toFixed(2) : 'N/A';
                const entropyColor = getEntropyColor(entropy);

                // Calculate dampening factor (if adjusted_complexity exists)
                let dampening = 'N/A';
                if (func.adjusted_complexity && func.adjusted_complexity.dampened_cyclomatic) {
                    dampening = (func.adjusted_complexity.dampened_cyclomatic / func.cyclomatic).toFixed(2);
                }

                row.innerHTML = `
                    <td class="px-6 py-4 text-sm font-mono">${func.name}</td>
                    <td class="px-6 py-4 text-sm text-gray-600">${func.file}</td>
                    <td class="px-6 py-4 text-sm">${func.cyclomatic}</td>
                    <td class="px-6 py-4 text-sm font-semibold ${getCognitiveColor(func.cognitive)}">${func.cognitive}</td>
                    <td class="px-6 py-4 text-sm">${func.nesting}</td>
                    <td class="px-6 py-4 text-sm ${entropyColor}">${entropyDisplay}</td>
                    <td class="px-6 py-4 text-sm text-gray-600">${dampening}</td>
                    <td class="px-6 py-4"><span class="px-2 py-1 rounded text-xs ${getPriorityBadge(func)}">${getPriority(func)}</span></td>
                `;
            });
        }

        function getEntropyColor(entropy) {
            if (entropy === 'N/A') return 'text-gray-400';
            if (entropy >= 0.5) return 'text-red-600 font-semibold';
            if (entropy >= 0.4) return 'text-orange-600';
            if (entropy >= 0.3) return 'text-yellow-600';
            return 'text-green-600';
        }

        function getCognitiveColor(cognitive) {
            if (cognitive >= 50) return 'text-red-600';
            if (cognitive >= 30) return 'text-orange-600';
            if (cognitive >= 20) return 'text-yellow-600';
            return 'text-green-600';
        }

        function getPriorityBadge(func) {
            const max = Math.max(func.cyclomatic, func.cognitive);
            if (max >= 20) return 'bg-red-100 text-red-800';
            if (max >= 15) return 'bg-orange-100 text-orange-800';
            if (max >= 10) return 'bg-yellow-100 text-yellow-800';
            return 'bg-green-100 text-green-800';
        }

        function getPriority(func) {
            const max = Math.max(func.cyclomatic, func.cognitive);
            if (max >= 20) return 'CRITICAL';
            if (max >= 15) return 'HIGH';
            if (max >= 10) return 'MEDIUM';
            return 'LOW';
        }

        // Search functionality
        document.getElementById('searchBox').addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const rows = document.getElementById('complexFunctionsBody').getElementsByTagName('tr');

            Array.from(rows).forEach(row => {
                const text = row.textContent.toLowerCase();
                row.style.display = text.includes(searchTerm) ? '' : 'none';
            });
        });

        // Initialize tables
        populateGodObjectsTable();
        populateComplexFunctionsTable();

        // Table sorting functionality
        document.querySelectorAll('table.sortable th').forEach((header, index) => {
            header.addEventListener('click', function() {
                const table = header.closest('table');
                sortTable(table, index);
            });
        });

        function sortTable(table, columnIndex) {
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            const header = table.querySelectorAll('th')[columnIndex];
            const isAscending = header.classList.contains('sorted-asc');

            table.querySelectorAll('th').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
            });

            rows.sort((a, b) => {
                const aValue = a.cells[columnIndex].textContent.trim();
                const bValue = b.cells[columnIndex].textContent.trim();

                const aNum = parseFloat(aValue);
                const bNum = parseFloat(bValue);

                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return isAscending ? bNum - aNum : aNum - bNum;
                }

                return isAscending ? bValue.localeCompare(aValue) : aValue.localeCompare(bValue);
            });

            rows.forEach(row => tbody.appendChild(row));

            header.classList.add(isAscending ? 'sorted-desc' : 'sorted-asc');
        }
    </script>
</body>
</html>
