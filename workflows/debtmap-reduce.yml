name: debtmap-parallel-elimination
mode: mapreduce

# Setup phase: Analyze the codebase and generate debt items
setup:
  - shell: "just coverage-lcov"
    
  - shell: "debtmap analyze src --lcov target/coverage/lcov.info --output debtmap.json --format json"

# Map phase: Process each debt item in parallel
map:
  # Input configuration - debtmap.json contains items array
  input: debtmap.json
  json_path: "$.items[*]"
  
  # Commands to execute for each debt item
  agent_template:
    commands:
      # Fix the specific debt item with clear, prescriptive instructions
      - claude: |
          /fix-debt-item --json '${item}' --rules '
          CRITICAL RULES:
          1. If this is a FILE AGGREGATE: Only fix the TOP 2 most complex functions listed, NOT the entire file
          2. If coverage is <80%: Write MINIMAL focused tests for uncovered branches ONLY
          3. DO NOT refactor working code unless cyclomatic complexity > 10
          4. DO NOT add abstraction layers, helper functions, or split functions unless complexity > 15
          5. DO NOT create new files or reorganize code structure
          6. Tests should be CONCISE - max 10 lines per test, test one thing
          
          For COVERAGE issues:
          - Look at "Uncovered lines" in the item
          - Write tests that specifically hit those lines/branches
          - Use existing test patterns from the codebase
          - Each test should be <10 lines
          
          For COMPLEXITY issues (only if cyclomatic > 10):
          - Extract ONLY if there is obvious duplication
          - Prefer early returns over nested ifs
          - Combine related conditions
          - DO NOT create "pure function" wrappers
          
          REMEMBER: Less code is better. Minimal changes. Test coverage > refactoring.'
        commit_required: true
        timeout: 300
        validate:
          claude: |
            /prodigy-validate-debt-fix --json '${item}' --output .prodigy/debt-validation-result.json --check '
            1. Did coverage increase for the specific function?
            2. If refactored, is the code actually simpler (fewer lines)?
            3. Do all tests pass?'
          result_file: ".prodigy/debt-validation-result.json"
          threshold: 90  # Debt item should be at least 90% resolved
          on_incomplete:
            claude: |
              /prodigy-complete-debt-fix --json '${item}' --gaps ${validation.gaps} --focus 'Add ONLY the missing test cases for uncovered lines.'
            max_attempts: 2
            fail_workflow: false  # Continue even if we can't fully resolve
            commit_required: true  # Require commit to verify fixes were made
      
      # Run tests to verify the fix
      - shell: "just test"
        on_failure:
          claude: "/prodigy-debug-test-failure --output '${shell.output}' --instruction 'Fix ONLY the failing test, do not refactor'"
          max_attempts: 3
          fail_workflow: false
      
      # Check formatting and linting
      - shell: "just fmt-check && just lint"
        on_failure:
          claude: "/prodigy-lint '${shell.output}' --instruction 'Fix formatting/lint issues only'"
          max_attempts: 2
          fail_workflow: false
  
  # Parallelization settings
  max_parallel: 3  # Fewer parallel agents for better quality
  timeout_per_agent: 600s  # 10 minutes per agent
  retry_on_failure: 1  # Retry once if an agent fails
  
  # Focus on high-impact items
  filter: "unified_score.final_score >= 20"  # Higher threshold - focus on worst issues
  sort_by: "unified_score.final_score DESC"  # Process highest score items first
  max_items: 5  # Fewer items, better quality

# Reduce phase: Aggregate results and finalize
reduce:
  commands:
    # Run full test suite after all fixes
    - shell: "just test"
      on_failure:
        claude: "/prodigy-debug-test-failure --output '${shell.output}' --instruction 'Fix test failures without adding new code'"
        max_attempts: 3
        fail_workflow: true  # Fail if tests don't pass after merging
    
    # Check formatting and linting
    - shell: "just fmt-check && just lint"
      on_failure:
        claude: "/prodigy-lint ${shell.output} --instruction 'Fix formatting only'"
        max_attempts: 2
        fail_workflow: false
          
    # Re-run debtmap to measure improvements
    - shell: "just coverage-lcov"
    
    - shell: "debtmap analyze src --lcov target/coverage/lcov.info --output debtmap-after.json --format json"
      capture_output: true
    
    # Compare debt metrics and create final commit with summary
    - claude: |
        /prodigy-compare-debt-results \
          --before debtmap.json \
          --after debtmap-after.json \
          --map-results '${map.results}' \
          --successful ${map.successful} \
          --failed ${map.failed} \
          --total ${map.total} \
          --check 'Verify: 1) Total debt score should be LOWER 2) Coverage % should be HIGHER 3) LOC should be SIMILAR or LOWER 4) Functions with complexity >10 should be FEWER. If debt score went UP or LOC increased significantly, mark as FAILED.'
      commit_required: true

