name: debtmap-parallel-elimination
mode: mapreduce

# Setup phase: Analyze the codebase and generate debt items
setup:
  - shell: "just coverage-lcov"
    
  - shell: "debtmap analyze src --lcov target/coverage/lcov.info --output debtmap.json --format json"

# Map phase: Process each debt item in parallel
map:
  # Input configuration - debtmap.json contains items array
  input: debtmap.json
  json_path: "$.items[*]"
  
  # Commands to execute for each debt item
  agent_template:
    commands:
      # Fix the specific debt item with clear instructions
      - claude: |
          Analyze this technical debt item and fix it following these rules:
          
          ${item}
          
          CRITICAL RULES:
          1. If this is a FILE AGGREGATE: Only fix the TOP 2 most complex functions listed, NOT the entire file
          2. If coverage is <80%: Write MINIMAL focused tests for uncovered branches ONLY
          3. DO NOT refactor working code unless cyclomatic complexity > 10
          4. DO NOT add abstraction layers, helper functions, or split functions unless complexity > 15
          5. DO NOT create new files or reorganize code structure
          6. Tests should be CONCISE - max 10 lines per test, test one thing
          
          For COVERAGE issues:
          - Look at "Uncovered lines" in the item
          - Write tests that specifically hit those lines/branches
          - Use existing test patterns from the codebase
          - Each test should be <10 lines
          
          For COMPLEXITY issues (only if cyclomatic > 10):
          - Extract ONLY if there's obvious duplication
          - Prefer early returns over nested ifs
          - Combine related conditions
          - DO NOT create "pure function" wrappers
          
          REMEMBER: Less code is better. Minimal changes. Test coverage > refactoring.
        commit_required: true
        timeout: 300
        validate:
          claude: |
            Check if the fix actually reduced debt:
            1. Did coverage increase for the specific function?
            2. If refactored, is the code actually simpler (fewer lines)?
            3. Do all tests pass?
            
            Output JSON: {"success": bool, "coverage_improved": bool, "complexity_reduced": bool}
          result_file: ".prodigy/debt-validation-result.json"
          threshold: 90
          on_incomplete:
            claude: |
              The fix was incomplete. Focus on:
              ${validation.gaps}
              
              Add ONLY the missing test cases for uncovered lines.
            max_attempts: 2
            fail_workflow: false
            commit_required: true
      
      # Run tests to verify the fix
      - shell: "just test"
        on_failure:
          claude: "Fix ONLY the failing test, don't refactor: ${shell.output}"
          max_attempts: 3
          fail_workflow: false
      
      # Check formatting and linting
      - shell: "just fmt-check && just lint"
        on_failure:
          claude: "Fix formatting/lint issues only: ${shell.output}"
          max_attempts: 2
          fail_workflow: false
  
  # Parallelization settings
  max_parallel: 3  # Fewer parallel agents for better quality
  timeout_per_agent: 600s
  retry_on_failure: 1
  
  # Focus on high-impact items
  filter: "unified_score.final_score >= 20"  # Higher threshold - focus on worst issues
  sort_by: "unified_score.final_score DESC"
  max_items: 5  # Fewer items, better quality

# Reduce phase: Aggregate results and finalize
reduce:
  commands:
    # Run full test suite after all fixes
    - shell: "just test"
      on_failure:
        claude: "Fix test failures without adding new code: ${shell.output}"
        max_attempts: 3
        fail_workflow: true
    
    # Check formatting and linting
    - shell: "just fmt-check && just lint"
      on_failure:
        claude: "Fix formatting only: ${shell.output}"
        max_attempts: 2
        fail_workflow: false
          
    # Re-run debtmap to measure improvements
    - shell: "just coverage-lcov"
    
    - shell: "debtmap analyze src --lcov target/coverage/lcov.info --output debtmap-after.json --format json"
      capture_output: true
    
    # Compare debt metrics and create final commit with summary
    - claude: |
        Compare the debt scores and create a summary:
        
        Before: debtmap.json
        After: debtmap-after.json
        
        Report:
        1. Total debt score change (should be LOWER)
        2. Coverage % change (should be HIGHER)
        3. Total lines of code change (should be SIMILAR or LOWER)
        4. Number of functions with complexity > 10 (should be LOWER)
        
        If debt score went UP or LOC increased significantly, mark as FAILED.
      commit_required: true