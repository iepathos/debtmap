// Integration tests for the compare command
// These tests verify the end-to-end workflow of comparing debtmap analyses

use anyhow::Result;

#[test]
fn test_compare_integration_placeholder() -> Result<()> {
    // Placeholder integration test
    // Full integration tests require actual debtmap output files
    // which are generated by running the full analysis pipeline.
    //
    // To run manual integration tests:
    // 1. Generate baseline: cargo run -- analyze --output before.json
    // 2. Make changes to codebase
    // 3. Generate new analysis: cargo run -- analyze --output after.json
    // 4. Run comparison: cargo run -- compare --before before.json --after after.json --output result.json
    // 5. Verify result.json contains expected comparison data

    Ok(())
}

#[test]
fn test_compare_command_compiles() {
    // This test ensures the compare module exports are correct
    use debtmap::comparison::{Comparator, PlanParser};
    use debtmap::comparison::types::{ComparisonResult, TargetStatus, DebtTrend};

    // Just verify types are accessible
    let _status = TargetStatus::Improved;
    let _trend = DebtTrend::Improving;

    // Test passes if compilation succeeds
}

#[test]
fn test_plan_parser_api() -> Result<()> {
    // Test that PlanParser has the expected API
    use debtmap::comparison::PlanParser;
    use std::path::PathBuf;

    // Create a temporary plan file for testing
    let temp_dir = std::env::temp_dir();
    let plan_path = temp_dir.join("test_plan.md");

    std::fs::write(&plan_path, r#"# Implementation Plan

## Target Item
**Location**: ./src/example.rs:complex_function:45

## Steps
1. Refactor the function
2. Add tests
"#)?;

    // Test extraction
    let location = PlanParser::extract_target_location(&plan_path)?;
    assert_eq!(location, "src/example.rs:complex_function:45");

    // Cleanup
    std::fs::remove_file(&plan_path).ok();

    Ok(())
}

#[test]
fn test_comparison_types_serialization() -> Result<()> {
    // Verify comparison result types can be serialized/deserialized
    use debtmap::comparison::types::{
        ComparisonMetadata, DebtTrend, TargetStatus, ComparisonSummary
    };
    use serde_json;

    // Test metadata serialization
    let metadata = ComparisonMetadata {
        comparison_date: "2025-10-01T10:00:00Z".to_string(),
        before_file: "before.json".to_string(),
        after_file: "after.json".to_string(),
        target_location: Some("src/test.rs:10".to_string()),
    };

    let json = serde_json::to_string(&metadata)?;
    let _deserialized: ComparisonMetadata = serde_json::from_str(&json)?;

    // Test enum serialization
    let status = TargetStatus::Improved;
    let json = serde_json::to_string(&status)?;
    let _deserialized: TargetStatus = serde_json::from_str(&json)?;

    let trend = DebtTrend::Improving;
    let json = serde_json::to_string(&trend)?;
    let _deserialized: DebtTrend = serde_json::from_str(&json)?;

    // Test summary serialization
    let summary = ComparisonSummary {
        target_improved: true,
        new_critical_count: 0,
        resolved_count: 5,
        overall_debt_trend: DebtTrend::Improving,
    };

    let json = serde_json::to_string(&summary)?;
    let _deserialized: ComparisonSummary = serde_json::from_str(&json)?;

    Ok(())
}

// Note: Full end-to-end integration tests should be added that:
// 1. Use actual debtmap analyze output (requires running full analysis)
// 2. Test complete workflows including:
//    - Detecting improvements
//    - Detecting regressions
//    - Detecting resolved items
//    - Tracking target items through plans
//    - Project health metrics
//
// These tests are deferred to avoid adding large JSON fixtures.
// They can be implemented as part of the CI/CD pipeline where
// real analyses are generated.
