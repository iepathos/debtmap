use debtmap::risk::lcov::parse_lcov_file;
use std::io::Write;
use std::path::PathBuf;
use tempfile::NamedTempFile;

/// This test reproduces the actual issue where paths from find_project_files
/// don't match the absolute paths in the LCOV file
#[test]
fn test_actual_path_mismatch_issue() {
    // Create LCOV data with absolute paths (as generated by tarpaulin)
    let lcov_content = r#"TN:
SF:/Users/glen/memento-mori/debtmap/src/analyzers/rust.rs
FN:100,analyze_rust_file
FNDA:10,analyze_rust_file
DA:100,10
DA:101,10
DA:102,5
DA:103,0
LF:4
LH:3
end_of_record
"#;

    let mut temp_file = NamedTempFile::new().unwrap();
    temp_file.write_all(lcov_content.as_bytes()).unwrap();

    let lcov_data = parse_lcov_file(temp_file.path()).unwrap();

    // These are the actual paths returned by find_project_files
    let path_from_root = PathBuf::from("./src/analyzers/rust.rs");
    let path_from_src = PathBuf::from("src/analyzers/rust.rs");

    println!("Testing path from root: {:?}", path_from_root);
    let coverage_from_root = lcov_data.get_function_coverage(&path_from_root, "analyze_rust_file");
    println!("Coverage from root: {:?}", coverage_from_root);

    println!("\nTesting path from src: {:?}", path_from_src);
    let coverage_from_src = lcov_data.get_function_coverage(&path_from_src, "analyze_rust_file");
    println!("Coverage from src: {:?}", coverage_from_src);

    // Both should find the coverage
    assert!(
        coverage_from_root.is_some(),
        "Should find coverage when analyzing from root with path {:?}",
        path_from_root
    );

    assert!(
        coverage_from_src.is_some(),
        "Should find coverage when analyzing from src with path {:?}",
        path_from_src
    );
}

/// Test to verify the fix: paths should be canonicalized or normalized
/// to match regardless of how they're specified
#[test]
fn test_path_normalization_fix() {
    // Create LCOV data with absolute paths
    let lcov_content = r#"TN:
SF:/Users/glen/memento-mori/debtmap/src/analyzers/rust.rs
FN:100,test_function
FNDA:10,test_function
DA:100,10
DA:101,0
LF:2
LH:1
end_of_record
"#;

    let mut temp_file = NamedTempFile::new().unwrap();
    temp_file.write_all(lcov_content.as_bytes()).unwrap();

    let lcov_data = parse_lcov_file(temp_file.path()).unwrap();

    // All these variations should match
    let test_paths = vec![
        "./src/analyzers/rust.rs", // Path from root with ./
        "src/analyzers/rust.rs",   // Path from src directory
        "/Users/glen/memento-mori/debtmap/src/analyzers/rust.rs", // Absolute path
    ];

    for path_str in test_paths {
        let path = PathBuf::from(path_str);
        let coverage = lcov_data.get_function_coverage(&path, "test_function");

        assert!(
            coverage.is_some(),
            "Path '{}' should match the LCOV data but got None",
            path_str
        );

        assert_eq!(
            coverage.unwrap(),
            0.5,
            "Path '{}' should return 50% coverage",
            path_str
        );
    }
}
