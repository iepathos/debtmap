â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Debtmap v0.1.8
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ TOP 10 RECOMMENDATIONS (by unified priority)

#1 SCORE: 5.05 [MEDIUM]
â”œâ”€ LOCATION: ./src/complexity/patterns.rs:209 PatternDetector::check_recursive_function_call()
â”œâ”€ ACTION: Extract 3 pure functions to reduce complexity from 5 to ~1
â”œâ”€ IMPACT: -2 complexity, -2.3 risk
â”œâ”€ COMPLEXITY: cyclomatic=5 (adj:5), branches=5, cognitive=11, nesting=4, entropy=0.51
â”œâ”€ DEPENDENCIES: 1 upstream, 0 downstream
â”‚  â”œâ”€ CALLERS: PatternDetector::handle_call_expr
â””â”€ WHY: Cyclomatic complexity of 5 is manageable but can be improved through extraction. Extracting 3 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Pure function extraction will create easily testable units with no side effects.

#2 SCORE: 5.05 [MEDIUM]
â”œâ”€ LOCATION: ./src/extraction_patterns/naming.rs:21 FunctionNameInferrer::generate_base_name()
â”œâ”€ ACTION: Extract 5 pure functions to reduce complexity from 15 to ~12
â”œâ”€ IMPACT: -7 complexity, -2.9 risk
â”œâ”€ COMPLEXITY: cyclomatic=15 (adj:14), branches=15, cognitive=21, nesting=2, entropy=0.42
â”œâ”€ DEPENDENCIES: 1 upstream, 2 downstream
â”‚  â”œâ”€ CALLERS: FunctionNameInferrer::infer_name
â”‚  â””â”€ CALLS: FunctionNameInferrer::pluralize, FunctionNameInferrer::singularize
â””â”€ WHY: Cyclomatic complexity of 15 indicates 15 independent paths, making comprehensive testing difficult. Extracting 5 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Consider isolating side effects during extraction.

#3 SCORE: 5.05 [MEDIUM]
â”œâ”€ LOCATION: ./src/extraction_patterns/language_specific/python_patterns.rs:181 PythonPatternMatcher::generate_example()
â”œâ”€ ACTION: Extract 2 pure functions (complexity 6 â†’ ~6)
â”œâ”€ IMPACT: -3 complexity, -2.3 risk
â”œâ”€ COMPLEXITY: cyclomatic=6 (adj:6), branches=6, cognitive=10, nesting=2, entropy=0.50
â”œâ”€ DEPENDENCIES: 1 upstream, 0 downstream
â”‚  â”œâ”€ CALLERS: PythonPatternMatcher::generate_extraction
â””â”€ WHY: Cyclomatic complexity of 6 means at least 6 test cases needed for full path coverage - extraction reduces this to 3-5 tests per function. Extracting 2 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Pure function extraction will create easily testable units with no side effects.

#4 SCORE: 5.05 [MEDIUM]
â”œâ”€ LOCATION: ./src/debt/circular.rs:68 DependencyGraph::dfs_detect_cycles()
â”œâ”€ ACTION: Extract 3 pure functions to reduce complexity from 6 to ~2
â”œâ”€ IMPACT: -3 complexity, -2.7 risk
â”œâ”€ COMPLEXITY: cyclomatic=6 (adj:5), branches=6, cognitive=13, nesting=4, entropy=0.34
â”œâ”€ DEPENDENCIES: 2 upstream, 4 downstream
â”‚  â”œâ”€ CALLERS: DependencyGraph::detect_circular_dependencies, DependencyGraph::dfs_detect_cycles
â”‚  â””â”€ CALLS: ContextMap::get, Applicative::unwrap, DependencyGraph::dfs_detect_cycles, ... (1 more)
â””â”€ WHY: Cyclomatic complexity of 6 means at least 6 test cases needed for full path coverage - extraction reduces this to 3-5 tests per function. Extracting 3 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Consider isolating side effects during extraction.

#5 SCORE: 5.05 [MEDIUM]
â”œâ”€ LOCATION: ./src/scoring/enhanced_scorer.rs:319 EnhancedScorer::calculate_frequency_factor()
â”œâ”€ ACTION: Extract 6 pure functions to reduce complexity from 15 to ~10
â”œâ”€ IMPACT: -7 complexity, -2.9 risk
â”œâ”€ COMPLEXITY: cyclomatic=15 (adj:14), branches=15, cognitive=27, nesting=4, entropy=0.42
â”œâ”€ DEPENDENCIES: 2 upstream, 1 downstream
â”‚  â”œâ”€ CALLERS: EnhancedScorer::score_function_with_aggregator, EnhancedScorer::score_debt_item
â”‚  â””â”€ CALLS: ContextMap::get
â””â”€ WHY: Cyclomatic complexity of 15 indicates 15 independent paths, making comprehensive testing difficult. Extracting 6 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Pure function extraction will create easily testable units with no side effects.

#6 SCORE: 5.05 [MEDIUM]
â”œâ”€ LOCATION: ./src/priority/call_graph.rs:259 CallGraph::get_transitive_callees()
â”œâ”€ ACTION: Extract 2 pure functions (complexity 5 â†’ ~5)
â”œâ”€ IMPACT: -2 complexity, -2.5 risk
â”œâ”€ COMPLEXITY: cyclomatic=5 (adj:5), branches=5, cognitive=9, nesting=3, entropy=0.44
â”œâ”€ DEPENDENCIES: 1 upstream, 2 downstream
â”‚  â”œâ”€ CALLERS: tests::test_transitive_dependencies
â”‚  â””â”€ CALLS: RiskAnalyzer::clone, CallGraph::get_callees
â””â”€ WHY: Cyclomatic complexity of 5 is manageable but can be improved through extraction. Extracting 2 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Consider isolating side effects during extraction.

#7 SCORE: 5.05 [MEDIUM]
â”œâ”€ LOCATION: ./src/risk/context/critical_path.rs:248 CriticalPathProvider::gather()
â”œâ”€ ACTION: Extract 3 pure functions to reduce complexity from 2 to ~0
â”œâ”€ IMPACT: -1 complexity, -2.6 risk
â”œâ”€ COMPLEXITY: cyclomatic=2 (adj:1), branches=2, cognitive=11, nesting=1, entropy=0.38
â”œâ”€ DEPENDENCIES: 6 upstream, 12 downstream
â”‚  â”œâ”€ CALLERS: tests::test_gather_with_no_entry_points, tests::test_gather_with_multiple_entry_points, ContextAggregator::analyze, ... (3 more)
â”‚  â””â”€ CALLS: CriticalPathProvider::calculate_contribution, CallGraph::is_empty, LazyPipeline::collect, ... (9 more)
â””â”€ WHY: Cyclomatic complexity of 2 is manageable but can be improved through extraction. Extracting 3 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Pure function extraction will create easily testable units with no side effects.

#8 SCORE: 5.05 [MEDIUM]
â”œâ”€ LOCATION: ./src/complexity/threshold_manager.rs:264 FunctionRole::from_name()
â”œâ”€ ACTION: Extract 4 pure functions to reduce complexity from 7 to ~4
â”œâ”€ IMPACT: -3 complexity, -2.3 risk
â”œâ”€ COMPLEXITY: cyclomatic=7 (adj:6), branches=7, cognitive=16, nesting=3, entropy=0.39
â””â”€ WHY: Cyclomatic complexity of 7 means at least 7 test cases needed for full path coverage - extraction reduces this to 3-5 tests per function. Extracting 4 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Pure function extraction will create easily testable units with no side effects.

#9 SCORE: 5.05 [MEDIUM]
â”œâ”€ LOCATION: ./src/main.rs:1481 create_unified_analysis_with_exclusions()
â”œâ”€ ACTION: Extract process_input_pipeline (confidence: 78%) to reduce complexity from 7 to ~3
â”œâ”€ IMPACT: -3 complexity, -2.4 risk
â”œâ”€ COMPLEXITY: cyclomatic=7 (adj:6), branches=7, cognitive=13, nesting=2, entropy=0.28
â”œâ”€ DEPENDENCIES: 2 upstream, 15 downstream
â”‚  â”œâ”€ CALLERS: calculate_unified_debt_score, perform_unified_analysis
â”‚  â””â”€ CALLS: UnifiedAnalysis::calculate_total_impact, UnifiedAnalysis::new, LazyPipeline::collect, ... (12 more)
â””â”€ WHY: Cyclomatic complexity of 7 indicates 7 independent paths requiring 7 test cases minimum - extraction will reduce this to 3-5 tests per function. Function has 1 extractable patterns that can be isolated. This extraction will create a focused, testable unit. Target complexity per function is 5 or less for optimal maintainability.

#10 SCORE: 5.05 [MEDIUM]
â”œâ”€ LOCATION: ./src/analyzers/javascript/detectors/testing.rs:149 detect_missing_assertions()
â”œâ”€ ACTION: Extract 6 pure functions to reduce complexity from 7 to ~0
â”œâ”€ IMPACT: -3 complexity, -2.8 risk
â”œâ”€ COMPLEXITY: cyclomatic=7 (adj:6), branches=7, cognitive=28, nesting=6, entropy=0.39
â”œâ”€ DEPENDENCIES: 1 upstream, 5 downstream
â”‚  â”œâ”€ CALLERS: detect_testing_patterns
â”‚  â””â”€ CALLS: has_assertions, ContextMap::iter, get_node_text, ... (2 more)
â””â”€ WHY: Cyclomatic complexity of 7 means at least 7 test cases needed for full path coverage - extraction reduces this to 3-5 tests per function. Extracting 6 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Consider isolating side effects during extraction.

ğŸ“Š TOTAL DEBT SCORE: 1325
