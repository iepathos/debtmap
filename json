════════════════════════════════════════════
    Debtmap v0.1.8
════════════════════════════════════════════

🎯 TOP 10 RECOMMENDATIONS (by unified priority)

#1 SCORE: 5.05 [MEDIUM]
├─ LOCATION: ./src/complexity/patterns.rs:209 PatternDetector::check_recursive_function_call()
├─ ACTION: Extract 3 pure functions to reduce complexity from 5 to ~1
├─ IMPACT: -2 complexity, -2.3 risk
├─ COMPLEXITY: cyclomatic=5 (adj:5), branches=5, cognitive=11, nesting=4, entropy=0.51
├─ DEPENDENCIES: 1 upstream, 0 downstream
│  ├─ CALLERS: PatternDetector::handle_call_expr
└─ WHY: Cyclomatic complexity of 5 is manageable but can be improved through extraction. Extracting 3 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Pure function extraction will create easily testable units with no side effects.

#2 SCORE: 5.05 [MEDIUM]
├─ LOCATION: ./src/extraction_patterns/naming.rs:21 FunctionNameInferrer::generate_base_name()
├─ ACTION: Extract 5 pure functions to reduce complexity from 15 to ~12
├─ IMPACT: -7 complexity, -2.9 risk
├─ COMPLEXITY: cyclomatic=15 (adj:14), branches=15, cognitive=21, nesting=2, entropy=0.42
├─ DEPENDENCIES: 1 upstream, 2 downstream
│  ├─ CALLERS: FunctionNameInferrer::infer_name
│  └─ CALLS: FunctionNameInferrer::pluralize, FunctionNameInferrer::singularize
└─ WHY: Cyclomatic complexity of 15 indicates 15 independent paths, making comprehensive testing difficult. Extracting 5 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Consider isolating side effects during extraction.

#3 SCORE: 5.05 [MEDIUM]
├─ LOCATION: ./src/extraction_patterns/language_specific/python_patterns.rs:181 PythonPatternMatcher::generate_example()
├─ ACTION: Extract 2 pure functions (complexity 6 → ~6)
├─ IMPACT: -3 complexity, -2.3 risk
├─ COMPLEXITY: cyclomatic=6 (adj:6), branches=6, cognitive=10, nesting=2, entropy=0.50
├─ DEPENDENCIES: 1 upstream, 0 downstream
│  ├─ CALLERS: PythonPatternMatcher::generate_extraction
└─ WHY: Cyclomatic complexity of 6 means at least 6 test cases needed for full path coverage - extraction reduces this to 3-5 tests per function. Extracting 2 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Pure function extraction will create easily testable units with no side effects.

#4 SCORE: 5.05 [MEDIUM]
├─ LOCATION: ./src/debt/circular.rs:68 DependencyGraph::dfs_detect_cycles()
├─ ACTION: Extract 3 pure functions to reduce complexity from 6 to ~2
├─ IMPACT: -3 complexity, -2.7 risk
├─ COMPLEXITY: cyclomatic=6 (adj:5), branches=6, cognitive=13, nesting=4, entropy=0.34
├─ DEPENDENCIES: 2 upstream, 4 downstream
│  ├─ CALLERS: DependencyGraph::detect_circular_dependencies, DependencyGraph::dfs_detect_cycles
│  └─ CALLS: ContextMap::get, Applicative::unwrap, DependencyGraph::dfs_detect_cycles, ... (1 more)
└─ WHY: Cyclomatic complexity of 6 means at least 6 test cases needed for full path coverage - extraction reduces this to 3-5 tests per function. Extracting 3 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Consider isolating side effects during extraction.

#5 SCORE: 5.05 [MEDIUM]
├─ LOCATION: ./src/scoring/enhanced_scorer.rs:319 EnhancedScorer::calculate_frequency_factor()
├─ ACTION: Extract 6 pure functions to reduce complexity from 15 to ~10
├─ IMPACT: -7 complexity, -2.9 risk
├─ COMPLEXITY: cyclomatic=15 (adj:14), branches=15, cognitive=27, nesting=4, entropy=0.42
├─ DEPENDENCIES: 2 upstream, 1 downstream
│  ├─ CALLERS: EnhancedScorer::score_function_with_aggregator, EnhancedScorer::score_debt_item
│  └─ CALLS: ContextMap::get
└─ WHY: Cyclomatic complexity of 15 indicates 15 independent paths, making comprehensive testing difficult. Extracting 6 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Pure function extraction will create easily testable units with no side effects.

#6 SCORE: 5.05 [MEDIUM]
├─ LOCATION: ./src/priority/call_graph.rs:259 CallGraph::get_transitive_callees()
├─ ACTION: Extract 2 pure functions (complexity 5 → ~5)
├─ IMPACT: -2 complexity, -2.5 risk
├─ COMPLEXITY: cyclomatic=5 (adj:5), branches=5, cognitive=9, nesting=3, entropy=0.44
├─ DEPENDENCIES: 1 upstream, 2 downstream
│  ├─ CALLERS: tests::test_transitive_dependencies
│  └─ CALLS: RiskAnalyzer::clone, CallGraph::get_callees
└─ WHY: Cyclomatic complexity of 5 is manageable but can be improved through extraction. Extracting 2 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Consider isolating side effects during extraction.

#7 SCORE: 5.05 [MEDIUM]
├─ LOCATION: ./src/risk/context/critical_path.rs:248 CriticalPathProvider::gather()
├─ ACTION: Extract 3 pure functions to reduce complexity from 2 to ~0
├─ IMPACT: -1 complexity, -2.6 risk
├─ COMPLEXITY: cyclomatic=2 (adj:1), branches=2, cognitive=11, nesting=1, entropy=0.38
├─ DEPENDENCIES: 6 upstream, 12 downstream
│  ├─ CALLERS: tests::test_gather_with_no_entry_points, tests::test_gather_with_multiple_entry_points, ContextAggregator::analyze, ... (3 more)
│  └─ CALLS: CriticalPathProvider::calculate_contribution, CallGraph::is_empty, LazyPipeline::collect, ... (9 more)
└─ WHY: Cyclomatic complexity of 2 is manageable but can be improved through extraction. Extracting 3 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Pure function extraction will create easily testable units with no side effects.

#8 SCORE: 5.05 [MEDIUM]
├─ LOCATION: ./src/complexity/threshold_manager.rs:264 FunctionRole::from_name()
├─ ACTION: Extract 4 pure functions to reduce complexity from 7 to ~4
├─ IMPACT: -3 complexity, -2.3 risk
├─ COMPLEXITY: cyclomatic=7 (adj:6), branches=7, cognitive=16, nesting=3, entropy=0.39
└─ WHY: Cyclomatic complexity of 7 means at least 7 test cases needed for full path coverage - extraction reduces this to 3-5 tests per function. Extracting 4 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Pure function extraction will create easily testable units with no side effects.

#9 SCORE: 5.05 [MEDIUM]
├─ LOCATION: ./src/main.rs:1481 create_unified_analysis_with_exclusions()
├─ ACTION: Extract process_input_pipeline (confidence: 78%) to reduce complexity from 7 to ~3
├─ IMPACT: -3 complexity, -2.4 risk
├─ COMPLEXITY: cyclomatic=7 (adj:6), branches=7, cognitive=13, nesting=2, entropy=0.28
├─ DEPENDENCIES: 2 upstream, 15 downstream
│  ├─ CALLERS: calculate_unified_debt_score, perform_unified_analysis
│  └─ CALLS: UnifiedAnalysis::calculate_total_impact, UnifiedAnalysis::new, LazyPipeline::collect, ... (12 more)
└─ WHY: Cyclomatic complexity of 7 indicates 7 independent paths requiring 7 test cases minimum - extraction will reduce this to 3-5 tests per function. Function has 1 extractable patterns that can be isolated. This extraction will create a focused, testable unit. Target complexity per function is 5 or less for optimal maintainability.

#10 SCORE: 5.05 [MEDIUM]
├─ LOCATION: ./src/analyzers/javascript/detectors/testing.rs:149 detect_missing_assertions()
├─ ACTION: Extract 6 pure functions to reduce complexity from 7 to ~0
├─ IMPACT: -3 complexity, -2.8 risk
├─ COMPLEXITY: cyclomatic=7 (adj:6), branches=7, cognitive=28, nesting=6, entropy=0.39
├─ DEPENDENCIES: 1 upstream, 5 downstream
│  ├─ CALLERS: detect_testing_patterns
│  └─ CALLS: has_assertions, ContextMap::iter, get_node_text, ... (2 more)
└─ WHY: Cyclomatic complexity of 7 means at least 7 test cases needed for full path coverage - extraction reduces this to 3-5 tests per function. Extracting 6 functions targets ~5 complexity per function - the sweet spot for maintainability where each function has a single clear purpose and can be tested with 3-5 test cases. Consider isolating side effects during extraction.

📊 TOTAL DEBT SCORE: 1325
