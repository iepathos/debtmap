<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Architecture - Debtmap Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive guide to Debtmap code complexity and technical debt analyzer">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Debtmap Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/iepathos/debtmap" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This chapter explains how debtmap’s analysis pipeline works, from discovering files to producing prioritized technical debt recommendations.</p>
<h2 id="analysis-pipeline-overview"><a class="header" href="#analysis-pipeline-overview">Analysis Pipeline Overview</a></h2>
<p>Debtmap’s analysis follows a multi-stage pipeline that transforms source code into actionable recommendations:</p>
<pre><code class="language-mermaid">graph TD
    A[File Discovery] --&gt; B[Language Detection]
    B --&gt; C{Parser}
    C --&gt;|Rust| D[syn AST]
    C --&gt;|Python| E[rustpython AST]
    C --&gt;|JS/TS| F[tree-sitter AST]

    D --&gt; G[Metric Extraction]
    E --&gt; G
    F --&gt; G

    G --&gt; H[Complexity Calculation]
    G --&gt; I[Call Graph Construction]
    G --&gt; J[Pattern Detection]

    H --&gt; K[Entropy Analysis]
    K --&gt; L[Effective Complexity]

    I --&gt; M[Dependency Analysis]
    J --&gt; N[Debt Classification]

    O[LCOV Coverage] --&gt; P[Coverage Mapping]
    P --&gt; Q[Risk Scoring]

    L --&gt; Q
    M --&gt; Q
    N --&gt; Q

    Q --&gt; R[Tiered Prioritization]
    R --&gt; S[Output Formatting]
    S --&gt; T[Terminal/JSON/Markdown]
</code></pre>
<h2 id="key-components"><a class="header" href="#key-components">Key Components</a></h2>
<h3 id="1-file-discovery-and-language-detection"><a class="header" href="#1-file-discovery-and-language-detection">1. File Discovery and Language Detection</a></h3>
<p><strong>Purpose:</strong> Identify source files to analyze and determine their language.</p>
<p><strong>How it works:</strong></p>
<ul>
<li>Walks the project directory tree (respecting <code>.gitignore</code> and <code>.debtmapignore</code>)</li>
<li>Detects language based on file extension (<code>.rs</code>, <code>.py</code>, <code>.js</code>, <code>.ts</code>)</li>
<li>Filters out test files, build artifacts, and vendored dependencies</li>
<li>Groups files by language for parallel processing</li>
</ul>
<p><strong>Configuration:</strong></p>
<pre><code class="language-toml">[analysis]
exclude_patterns = ["**/tests/**", "**/target/**", "**/node_modules/**"]
include_patterns = ["src/**/*.rs", "lib/**/*.py"]
</code></pre>
<h3 id="2-parser-layer"><a class="header" href="#2-parser-layer">2. Parser Layer</a></h3>
<p><strong>Purpose:</strong> Convert source code into Abstract Syntax Trees (ASTs) for analysis.</p>
<p><strong>Language-Specific Parsers:</strong></p>
<p><strong>Rust (syn):</strong></p>
<ul>
<li>Uses the <code>syn</code> crate for full Rust syntax support</li>
<li>Extracts: functions, structs, impls, traits, macros</li>
<li>Handles: async/await, generic types, lifetime annotations</li>
<li>Performance: ~10-20ms per file</li>
</ul>
<p><strong>Python (rustpython):</strong></p>
<ul>
<li>Uses rustpython’s parser for Python 3.x syntax</li>
<li>Extracts: functions, classes, methods, decorators</li>
<li>Handles: comprehensions, async/await, type hints</li>
<li>Performance: ~5-15ms per file</li>
</ul>
<p><strong>JavaScript/TypeScript (tree-sitter):</strong></p>
<ul>
<li>Uses tree-sitter for JS/TS parsing</li>
<li>Extracts: functions, classes, arrow functions, hooks</li>
<li>Handles: JSX/TSX, decorators, generics</li>
<li>Performance: ~8-18ms per file</li>
</ul>
<p><strong>Error Handling:</strong></p>
<ul>
<li>Syntax errors logged but don’t stop analysis</li>
<li>Partial ASTs used when possible</li>
<li>Files with parse errors excluded from final report</li>
</ul>
<h3 id="3-metric-extraction"><a class="header" href="#3-metric-extraction">3. Metric Extraction</a></h3>
<p><strong>Purpose:</strong> Extract raw metrics from ASTs.</p>
<p><strong>Metrics Computed:</strong></p>
<p><strong>Function-Level:</strong></p>
<ul>
<li>Lines of code (LOC)</li>
<li>Cyclomatic complexity (branch count)</li>
<li>Nesting depth (max indentation level)</li>
<li>Parameter count</li>
<li>Return path count</li>
<li>Comment ratio</li>
</ul>
<p><strong>File-Level:</strong></p>
<ul>
<li>Total LOC</li>
<li>Number of functions/classes</li>
<li>Dependency count (imports)</li>
<li>Documentation coverage</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FunctionMetrics {
    pub name: String,
    pub location: Location,
    pub loc: u32,
    pub cyclomatic_complexity: u32,
    pub nesting_depth: u32,
    pub parameter_count: u32,
    pub return_paths: u32,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-complexity-calculation-and-entropy-analysis"><a class="header" href="#4-complexity-calculation-and-entropy-analysis">4. Complexity Calculation and Entropy Analysis</a></h3>
<p><strong>Purpose:</strong> Compute effective complexity using entropy-adjusted metrics.</p>
<p><strong>Traditional Cyclomatic Complexity:</strong></p>
<ul>
<li>Count decision points (if, match, loop, etc.)</li>
<li>Each branch adds +1 to complexity</li>
<li>Does not distinguish between repetitive and varied logic</li>
</ul>
<p><strong>Entropy-Based Adjustment:</strong></p>
<p>Debtmap calculates pattern entropy to adjust cyclomatic complexity:</p>
<ol>
<li><strong>Extract patterns</strong> - Identify branch structures (e.g., all if/return patterns)</li>
<li><strong>Calculate variety</strong> - Measure information entropy of patterns</li>
<li><strong>Adjust complexity</strong> - Reduce score for low-entropy (repetitive) code</li>
</ol>
<p><strong>Formula:</strong></p>
<pre><code>Entropy = -Σ(p_i * log2(p_i))

where p_i = frequency of pattern i

Effective Complexity = Cyclomatic * (1 - (1 - Entropy/Max_Entropy) * 0.75)
</code></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 20 similar if/return statements
// Cyclomatic: 20, Entropy: 0.3
// Effective: 20 * (1 - (1 - 0.3/4.32) * 0.75) ≈ 5.5
<span class="boring">}</span></code></pre></pre>
<p>This approach reduces false positives from validation/configuration code while still flagging genuinely complex logic.</p>
<h3 id="5-call-graph-construction"><a class="header" href="#5-call-graph-construction">5. Call Graph Construction</a></h3>
<p><strong>Purpose:</strong> Understand function dependencies and identify critical paths.</p>
<p><strong>What’s Tracked:</strong></p>
<ul>
<li>Function calls within the same file</li>
<li>Cross-file calls (when possible to resolve)</li>
<li>Method calls on structs/classes</li>
<li>Trait/interface implementations</li>
</ul>
<p><strong>Analysis:</strong></p>
<ul>
<li><strong>Fan-in:</strong> How many functions call this function</li>
<li><strong>Fan-out:</strong> How many functions this function calls</li>
<li><strong>Depth:</strong> Distance from entry points (main, handlers)</li>
<li><strong>Cycles:</strong> Detect recursive calls</li>
</ul>
<p><strong>Usage:</strong></p>
<ul>
<li>Prioritize functions called from many untested paths</li>
<li>Identify central functions (high fan-in/fan-out)</li>
<li>Detect test coverage gaps in critical paths</li>
</ul>
<p><strong>Limitations:</strong></p>
<ul>
<li>Dynamic dispatch not fully resolved</li>
<li>Cross-crate calls require additional analysis</li>
<li>Closures and function pointers approximated</li>
</ul>
<h3 id="6-pattern-detection-and-debt-classification"><a class="header" href="#6-pattern-detection-and-debt-classification">6. Pattern Detection and Debt Classification</a></h3>
<p><strong>Purpose:</strong> Identify specific technical debt patterns.</p>
<p><strong>Debt Categories:</strong></p>
<p><strong>Test Gaps:</strong></p>
<ul>
<li>Functions with 0% coverage and high complexity</li>
<li>Untested error paths</li>
<li>Missing edge case tests</li>
</ul>
<p><strong>Complexity Issues:</strong></p>
<ul>
<li>Functions exceeding thresholds (default: 10)</li>
<li>Deep nesting (3+ levels)</li>
<li>Long functions (200+ LOC)</li>
</ul>
<p><strong>Design Smells:</strong></p>
<ul>
<li>God functions (high fan-out)</li>
<li>Unused code (fan-in = 0)</li>
<li>Circular dependencies</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum DebtType {
    TestGap { missing_tests: u32 },
    HighComplexity { score: u32 },
    DeepNesting { depth: u32 },
    LongFunction { loc: u32 },
    TooManyParams { count: u32 },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="7-coverage-integration"><a class="header" href="#7-coverage-integration">7. Coverage Integration</a></h3>
<p><strong>Purpose:</strong> Map test coverage data to complexity metrics for risk scoring.</p>
<p><strong>Coverage Data Flow:</strong></p>
<ol>
<li><strong>Read LCOV file</strong> - Parse coverage report from test runners</li>
<li><strong>Map to source</strong> - Match coverage lines to functions/branches</li>
<li><strong>Calculate coverage %</strong> - For each function, compute:
<ul>
<li>Line coverage: % of lines executed</li>
<li>Branch coverage: % of branches taken</li>
</ul>
</li>
<li><strong>Identify gaps</strong> - Find untested branches in complex functions</li>
</ol>
<p><strong>Coverage Scoring:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CoverageMetrics {
    pub lines_covered: u32,
    pub lines_total: u32,
    pub branches_covered: u32,
    pub branches_total: u32,
    pub coverage_percent: f64,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Special Cases:</strong></p>
<ul>
<li>Entry points (main, handlers) expect integration test coverage</li>
<li>Generated code excluded from coverage requirements</li>
<li>Test files themselves not analyzed for coverage</li>
</ul>
<h3 id="8-risk-scoring"><a class="header" href="#8-risk-scoring">8. Risk Scoring</a></h3>
<p><strong>Purpose:</strong> Combine complexity and coverage into a unified risk score.</p>
<p><strong>Risk Formula:</strong></p>
<pre><code>Risk Score = (Effective Complexity * Coverage Gap Weight) + (Call Graph Depth * Path Weight)

where:
- Effective Complexity: Entropy-adjusted cyclomatic complexity
- Coverage Gap Weight: 1.0 for 0% coverage, decreasing to 0.1 for 95%+
- Call Graph Depth: Distance from entry points
- Path Weight: Number of untested paths leading to this function
</code></pre>
<p><strong>Example Calculation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_risk_score():
  Effective Complexity: 8.5
  Coverage: 30%
  Coverage Gap Weight: 0.7
  Call Graph Depth: 3
  Untested Paths: 2

  Risk = (8.5 * 0.7) + (3 * 2 * 0.3) = 5.95 + 1.8 = 7.75
<span class="boring">}</span></code></pre></pre>
<p><strong>Risk Tiers:</strong></p>
<ul>
<li><strong>Critical (8.0+):</strong> Immediate attention required</li>
<li><strong>High (5.0-7.9):</strong> Priority for next sprint</li>
<li><strong>Moderate (2.0-4.9):</strong> Address when refactoring nearby code</li>
<li><strong>Low (&lt;2.0):</strong> Monitor but no immediate action</li>
</ul>
<h3 id="9-tiered-prioritization"><a class="header" href="#9-tiered-prioritization">9. Tiered Prioritization</a></h3>
<p><strong>Purpose:</strong> Classify and rank technical debt items by urgency and impact.</p>
<p><strong>Prioritization Algorithm:</strong></p>
<ol>
<li><strong>Calculate base risk score</strong> (from Risk Scoring step)</li>
<li><strong>Apply context adjustments:</strong>
<ul>
<li>Entry points: -2.0 score (lower priority for unit tests)</li>
<li>Core business logic: +1.5 score (higher priority)</li>
<li>Frequently changed files: +1.0 score (git history analysis)</li>
<li>Critical paths: +0.5 score per untested caller</li>
</ul>
</li>
<li><strong>Classify into tiers:</strong>
<ul>
<li>Critical: score &gt;= 8.0</li>
<li>High: score &gt;= 5.0</li>
<li>Moderate: score &gt;= 2.0</li>
<li>Low: score &lt; 2.0</li>
</ul>
</li>
<li><strong>Sort within tiers by:</strong>
<ul>
<li>Impact (estimated risk reduction)</li>
<li>Effort (test count or refactoring size)</li>
<li>ROI (impact / effort)</li>
</ul>
</li>
</ol>
<p><strong>Output:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PrioritizedDebtItem {
    pub rank: u32,
    pub score: f64,
    pub tier: Tier,
    pub location: Location,
    pub debt_type: DebtType,
    pub action: String,
    pub impact: f64,
    pub effort: Effort,
}
<span class="boring">}</span></code></pre></pre>
<p>See <a href="tiered-prioritization.html">Tiered Prioritization</a> for detailed explanation of the ranking algorithm.</p>
<h3 id="10-output-formatting"><a class="header" href="#10-output-formatting">10. Output Formatting</a></h3>
<p><strong>Purpose:</strong> Present analysis results in user-friendly formats.</p>
<p><strong>Output Formats:</strong></p>
<p><strong>Terminal (default):</strong></p>
<ul>
<li>Color-coded by tier (red=critical, yellow=high, etc.)</li>
<li>Hierarchical tree view with unicode box characters</li>
<li>Collapsible sections for detailed recommendations</li>
<li>Summary statistics at top</li>
</ul>
<p><strong>JSON:</strong></p>
<ul>
<li>Machine-readable for CI/CD integration</li>
<li>Full metadata for each debt item</li>
<li>Structured for programmatic consumption</li>
<li>Schema-versioned for compatibility</li>
</ul>
<p><strong>Markdown:</strong></p>
<ul>
<li>Rendered in GitHub/GitLab for PR comments</li>
<li>Embedded code blocks with syntax highlighting</li>
<li>Collapsible details sections</li>
<li>Linked to source code locations</li>
</ul>
<p><strong>GitHub PR Comments:</strong></p>
<ul>
<li>Automated comments on pull requests</li>
<li>Inline annotations at specific lines</li>
<li>Comparison with base branch (new vs existing debt)</li>
<li>Summary card with key metrics</li>
</ul>
<p>See <a href="output-formats.html">Output Formats</a> for examples and configuration options.</p>
<h2 id="data-flow-example"><a class="header" href="#data-flow-example">Data Flow Example</a></h2>
<p>Let’s trace a single function through the entire pipeline:</p>
<p><strong>Input: Source File</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/handlers.rs
pub fn process_request(req: Request) -&gt; Result&lt;Response&gt; {
    validate_auth(&amp;req)?;
    let data = parse_payload(&amp;req.body)?;
    let result = apply_business_logic(data)?;
    format_response(result)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Stage 1: Parsing</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FunctionAst {
    name: "process_request",
    location: Location { file: "src/handlers.rs", line: 2 },
    calls: ["validate_auth", "parse_payload", "apply_business_logic", "format_response"],
    ...
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Stage 2: Metric Extraction</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FunctionMetrics {
    name: "process_request",
    cyclomatic_complexity: 4,  // 3 ?-operators + base
    nesting_depth: 1,
    loc: 5,
    ...
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Stage 3: Entropy Analysis</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern: repetitive ?-operator error handling
Entropy: 0.4 (low variety)
Effective Complexity: 4 * 0.85 = 3.4
<span class="boring">}</span></code></pre></pre>
<p><strong>Stage 4: Call Graph</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CallGraphNode {
    function: "process_request",
    fan_in: 3,  // called from 3 handlers
    fan_out: 4,  // calls 4 functions
    depth: 1,  // direct handler (entry point)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Stage 5: Coverage (from LCOV)</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CoverageMetrics {
    lines_covered: 5,
    lines_total: 5,
    branches_covered: 3,
    branches_total: 4,  // Missing one error path
    coverage_percent: 75%,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Stage 6: Risk Scoring</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Risk = (3.4 * 0.25) + (1 * 1 * 0.2) = 0.85 + 0.2 = 1.05
Tier: LOW (entry point with decent coverage)
<span class="boring">}</span></code></pre></pre>
<p><strong>Stage 7: Recommendation</strong></p>
<pre><code>#23 SCORE: 1.1 [LOW]
├─ MINOR GAP: ./src/handlers.rs:2 process_request()
├─ ACTION: Add 1 test for error path at line 3
├─ IMPACT: -0.3 risk reduction
└─ WHY: Entry point with 75% branch coverage, missing error case
</code></pre>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<p><strong>Analysis Speed:</strong></p>
<ul>
<li>Small project (&lt; 10k LOC): 1-3 seconds</li>
<li>Medium project (10-50k LOC): 5-15 seconds</li>
<li>Large project (50-200k LOC): 20-60 seconds</li>
<li>Very large project (200k+ LOC): 1-5 minutes</li>
</ul>
<p><strong>Parallelization:</strong></p>
<ul>
<li>File parsing: Parallel across all available cores</li>
<li>Metric extraction: Parallel per-file</li>
<li>Call graph construction: Sequential (requires cross-file state)</li>
<li>Risk scoring: Parallel per-function</li>
<li>Output formatting: Sequential</li>
</ul>
<p><strong>Memory Usage:</strong></p>
<ul>
<li>Approx 100-200 KB per file analyzed</li>
<li>Peak memory for large projects: 500 MB - 1 GB</li>
<li>Streaming mode available for very large codebases</li>
</ul>
<p><strong>Optimization Strategies:</strong></p>
<ul>
<li>Incremental analysis (cache previous results)</li>
<li>Skip unchanged files (git diff integration)</li>
<li>Parallel processing with rayon</li>
<li>Efficient AST traversal (visitor pattern)</li>
</ul>
<h2 id="extension-points"><a class="header" href="#extension-points">Extension Points</a></h2>
<p><strong>Custom Analyzers:</strong>
Implement the <code>Analyzer</code> trait to add language support:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Analyzer {
    fn parse(&amp;self, content: &amp;str) -&gt; Result&lt;Ast&gt;;
    fn extract_metrics(&amp;self, ast: &amp;Ast) -&gt; Vec&lt;FunctionMetrics&gt;;
    fn detect_patterns(&amp;self, ast: &amp;Ast) -&gt; Vec&lt;DebtPattern&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Custom Scoring:</strong>
Implement the <code>RiskScorer</code> trait to adjust scoring logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait RiskScorer {
    fn calculate_risk(&amp;self, metrics: &amp;FunctionMetrics, coverage: &amp;CoverageMetrics) -&gt; f64;
    fn classify_tier(&amp;self, score: f64) -&gt; Tier;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Custom Output:</strong>
Implement the <code>OutputFormatter</code> trait for new formats:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait OutputFormatter {
    fn format(&amp;self, items: &amp;[PrioritizedDebtItem]) -&gt; Result&lt;String&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><strong>Understand prioritization:</strong> See <a href="tiered-prioritization.html">Tiered Prioritization</a></li>
<li><strong>Learn scoring strategies:</strong> See <a href="scoring-strategies.html">Scoring Strategies</a></li>
<li><strong>Configure analysis:</strong> See <a href="configuration.html">Configuration</a></li>
<li><strong>View examples:</strong> See <a href="examples.html">Examples</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="output-formats.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="cache-management.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="output-formats.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="cache-management.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
