# Improved Debtmap Configuration with False Positive Reduction

[scoring]
# Weights for different scoring factors (must sum to 1.0)
# Using weighted sum model for clear, predictable scoring
coverage = 0.50      # Weight for test coverage gaps (50% - prioritize untested code)
complexity = 0.35    # Weight for code complexity (35% - identify complex areas)
dependency = 0.15    # Weight for dependency criticality (15% - consider impact radius)

[thresholds]
complexity = 10
duplication = 50
max_file_length = 500
max_function_length = 50

# Minimum thresholds for including items in debt analysis
# These help filter out trivial functions that aren't really technical debt
minimum_debt_score = 2.0              # Increased from 1.0 to filter out minor issues
minimum_cyclomatic_complexity = 3     # Increased from 1 to skip simple functions
minimum_cognitive_complexity = 5      # Increased from 1 to skip simple cognitive load
minimum_risk_score = 2.0              # Increased from 1.0 for Risk debt types

# Validation thresholds for 'debtmap validate' command
[thresholds.validation]
max_average_complexity = 10.0         # Maximum allowed average complexity
max_high_complexity_count = 100       # Maximum allowed high complexity functions
max_debt_items = 2500                 # Maximum allowed technical debt items
max_total_debt_score = 1000           # Maximum allowed total debt score (unified scoring)
max_codebase_risk_score = 7.0         # Maximum allowed codebase risk score
max_high_risk_functions = 50          # Maximum allowed high-risk functions
min_coverage_percentage = 0.0         # Minimum required code coverage percentage (0 = no minimum)

[languages]
enabled = ["rust", "javascript", "python", "go"]

[ignore]
patterns = [
    "target/**",
    "venv/**",
    "node_modules/**",
    "*.min.js",
    "benches/**",
    "tests/**/*",           # Exclude all files in tests directory
    "**/test_*.rs",         # Exclude test files with test_ prefix
    "**/*_test.rs",         # Exclude test files with _test suffix
    "**/*_tests.rs",        # Exclude test files with _tests suffix
    "**/fixtures/**",       # Exclude test fixtures
    "**/mocks/**",          # Exclude mock implementations
    "**/stubs/**",          # Exclude stub implementations
    "**/examples/**",       # Exclude example code
    "**/demo/**",           # Exclude demo code
    "**/*_demo.rs",         # Exclude demo files
    "**/testdata/**",       # Exclude test data directories
]

# Function name patterns to ignore - common patterns that are intentionally complex
[ignore.functions]
patterns = [
    # Test setup/teardown that are naturally complex
    "setup_test_*",
    "teardown_test_*",
    "create_test_*",
    "mock_*",
    
    # Generated or macro-expanded code patterns
    "derive_*",
    "__*",  # Dunder methods
    
    # CLI argument parsing - naturally complex
    "parse_args",
    "parse_cli",
    "build_cli",
    
    # Serialization/deserialization - naturally complex pattern matching
    "serialize_*",
    "deserialize_*",
    "to_json",
    "from_json",
    "to_*_format",
    "from_*_format",
]

[output]
default_format = "terminal"

[external_api]
# Enable automatic external API detection for testing
detect_external_api = false

# However, we can still explicitly mark certain functions as APIs if needed
# (Currently empty since debtmap doesn't expose any external APIs)
api_functions = []
api_files = []

[entropy]
enabled = true
weight = 0.5
min_tokens = 10
pattern_threshold = 0.7

# Pattern-specific adjustments to reduce false positives
[patterns]
# Detector functions often have moderate complexity by design
[patterns.detectors]
name_patterns = ["detect_*", "check_*", "validate_*", "verify_*"]
complexity_adjustment = 0.7  # Reduce complexity score by 30% for detector patterns
cognitive_adjustment = 0.8   # Reduce cognitive complexity by 20%

# Builder patterns often have chained method calls
[patterns.builders]
name_patterns = ["*Builder", "builder", "with_*", "set_*"]
orchestration_threshold = 5  # Need at least 5 delegations to be considered orchestration
complexity_adjustment = 0.8  # Reduce complexity score by 20%

# Pattern matching functions are idiomatic in Rust
[patterns.matching]
name_patterns = ["match_*", "classify_*", "categorize_*", "determine_*"]
complexity_adjustment = 0.6  # Reduce complexity score by 40% for pattern matching
cognitive_adjustment = 0.7   # Reduce cognitive complexity by 30%

# Error handling functions naturally have branching
[patterns.error_handling]
name_patterns = ["handle_error", "process_error", "map_error", "convert_error"]
complexity_adjustment = 0.7  # Reduce complexity score by 30%

# Configuration loading is naturally complex
[patterns.configuration]
name_patterns = ["load_config", "parse_config", "init_*", "setup_*"]
complexity_adjustment = 0.8  # Reduce complexity score by 20%
minimum_complexity = 15      # Only flag if complexity > 15

# Visitor pattern implementations
[patterns.visitors]
name_patterns = ["visit_*", "walk_*", "traverse_*"]
orchestration_threshold = 6  # Need at least 6 delegations
complexity_adjustment = 0.7  # Reduce complexity score by 30%

# God Object detection configuration
[god_object]
enabled = true                # Enable god object detection
max_methods = 20              # Maximum methods before considering a god object
max_fields = 15               # Maximum fields before considering a god object  
max_responsibilities = 5      # Maximum distinct responsibilities
score_threshold = 50.0        # Minimum score to flag as god object

# Language-specific thresholds
[god_object.rust]
max_methods = 25              # Rust allows more methods due to trait impls
max_fields = 15
max_responsibilities = 4

[god_object.python]
max_methods = 20
max_fields = 20               # Python classes often have more attributes
max_responsibilities = 5

[god_object.javascript]
max_methods = 15              # JavaScript classes should be smaller
max_fields = 10
max_responsibilities = 3
