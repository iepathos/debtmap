# Improved Debtmap Configuration with False Positive Reduction

[scoring]
# Weights for different scoring factors (must sum to 1.0)
# ROI has been removed from scoring - weights redistributed to other factors
coverage = 0.40      # Weight for test coverage gaps (40%)
complexity = 0.30    # Weight for code complexity (30%)
semantic = 0.05     # Weight for semantic importance (5%)
dependency = 0.15   # Weight for dependency criticality (15%)
security = 0.05     # Weight for security issues (5%)
organization = 0.05 # Weight for code organization issues (5%)

[thresholds]
complexity = 10
duplication = 50
max_file_length = 500
max_function_length = 50

# Minimum thresholds for including items in debt analysis
# These help filter out trivial functions that aren't really technical debt
minimum_debt_score = 2.0              # Increased from 1.0 to filter out minor issues
minimum_cyclomatic_complexity = 3     # Increased from 1 to skip simple functions
minimum_cognitive_complexity = 5      # Increased from 1 to skip simple cognitive load
minimum_risk_score = 2.0              # Increased from 1.0 for Risk debt types

# Validation thresholds for 'debtmap validate' command
[thresholds.validation]
max_average_complexity = 10.0         # Maximum allowed average complexity
max_high_complexity_count = 100       # Maximum allowed high complexity functions
max_debt_items = 2500                 # Maximum allowed technical debt items
max_total_debt_score = 1000           # Maximum allowed total debt score (unified scoring)
max_codebase_risk_score = 7.0         # Maximum allowed codebase risk score
max_high_risk_functions = 50          # Maximum allowed high-risk functions
min_coverage_percentage = 0.0         # Minimum required code coverage percentage (0 = no minimum)

[languages]
enabled = ["rust", "javascript", "python", "go"]

[ignore]
patterns = [
    "target/**",
    "venv/**",
    "node_modules/**",
    "*.min.js",
    "benches/**",
    "tests/**/*",           # Exclude all files in tests directory
    "**/test_*.rs",         # Exclude test files with test_ prefix
    "**/*_test.rs",         # Exclude test files with _test suffix
    "**/*_tests.rs",        # Exclude test files with _tests suffix
    "**/fixtures/**",       # Exclude test fixtures
    "**/mocks/**",          # Exclude mock implementations
    "**/stubs/**",          # Exclude stub implementations
    "**/examples/**",       # Exclude example code
    "**/demo/**",           # Exclude demo code
    "**/*_demo.rs",         # Exclude demo files
    "**/testdata/**",       # Exclude test data directories
]

# Function name patterns to ignore - common patterns that are intentionally complex
[ignore.functions]
patterns = [
    # Test setup/teardown that are naturally complex
    "setup_test_*",
    "teardown_test_*",
    "create_test_*",
    "mock_*",
    
    # Generated or macro-expanded code patterns
    "derive_*",
    "__*",  # Dunder methods
    
    # CLI argument parsing - naturally complex
    "parse_args",
    "parse_cli",
    "build_cli",
    
    # Serialization/deserialization - naturally complex pattern matching
    "serialize_*",
    "deserialize_*",
    "to_json",
    "from_json",
    "to_*_format",
    "from_*_format",
]

[output]
default_format = "terminal"

[external_api]
# Enable automatic external API detection for testing
detect_external_api = false

# However, we can still explicitly mark certain functions as APIs if needed
# (Currently empty since debtmap doesn't expose any external APIs)
api_functions = []
api_files = []

[orchestration]
# Configuration for orchestration detection to reduce false positives

# Minimum number of meaningful function delegations to be considered orchestration
# Increased from 2 to 3 to reduce false positives
min_delegations = 3

# Whether to exclude adapter patterns (single delegation with data transformation)
# Default: true (adapters are not considered orchestration)
exclude_adapters = true

# Whether to recognize functional chains (map/filter/collect) as idiomatic patterns
# Default: true (functional chains are not considered orchestration)
allow_functional_chains = true

# Additional function name patterns to exclude from orchestration detection
# These patterns will never be considered orchestration regardless of structure
exclude_patterns = [
    # Simple delegation patterns
    "*_wrapper",
    "*_adapter",
    "convert_*",
    "transform_*",
    "map_*",
    "translate_*",
    
    # Proxy/facade patterns
    "*_proxy",
    "*_facade",
    
    # Factory methods that delegate
    "create_*",
    "build_*",
    "make_*",
    
    # Visitor pattern methods
    "visit_*",
    "walk_*",
    "traverse_*",
]

# Additional function name patterns to always consider as orchestration
# These patterns will be considered orchestration if they meet minimum requirements
include_patterns = [
    "workflow_*",
    "pipeline_*",
    "process_*",
    "orchestrate_*",
    "coordinate_*",
    "execute_flow_*",
]

[entropy]
enabled = true
weight = 0.5
min_tokens = 10
pattern_threshold = 0.7

# Pattern-specific adjustments to reduce false positives
[patterns]
# Detector functions often have moderate complexity by design
[patterns.detectors]
name_patterns = ["detect_*", "check_*", "validate_*", "verify_*"]
complexity_adjustment = 0.7  # Reduce complexity score by 30% for detector patterns
cognitive_adjustment = 0.8   # Reduce cognitive complexity by 20%

# Builder patterns often have chained method calls
[patterns.builders]
name_patterns = ["*Builder", "builder", "with_*", "set_*"]
orchestration_threshold = 5  # Need at least 5 delegations to be considered orchestration
complexity_adjustment = 0.8  # Reduce complexity score by 20%

# Pattern matching functions are idiomatic in Rust
[patterns.matching]
name_patterns = ["match_*", "classify_*", "categorize_*", "determine_*"]
complexity_adjustment = 0.6  # Reduce complexity score by 40% for pattern matching
cognitive_adjustment = 0.7   # Reduce cognitive complexity by 30%

# Error handling functions naturally have branching
[patterns.error_handling]
name_patterns = ["handle_error", "process_error", "map_error", "convert_error"]
complexity_adjustment = 0.7  # Reduce complexity score by 30%

# Configuration loading is naturally complex
[patterns.configuration]
name_patterns = ["load_config", "parse_config", "init_*", "setup_*"]
complexity_adjustment = 0.8  # Reduce complexity score by 20%
minimum_complexity = 15      # Only flag if complexity > 15

# Visitor pattern implementations
[patterns.visitors]
name_patterns = ["visit_*", "walk_*", "traverse_*"]
orchestration_threshold = 6  # Need at least 6 delegations
complexity_adjustment = 0.7  # Reduce complexity score by 30%